
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>To iterate is human, to recurse divine.</title>
  <meta name="author" content="">

  
  <meta name="description" content="现在，我们已经用Prolog实现了范例Scheme语言的源代码读取、词法分析和语法分析的部分，并且获得了AST。最后，我们要实现一个Scheme的运行时来消费AST，生成最终的计算结果。 当解析器生成了抽象语法树(AST)后，运行时环境可以对它进行处理，计算语法树表达的数值。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://isaachan.github.com">
  <link href="/favicon.ico" rel="icon">
  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="To iterate is human, to recurse divine." type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42344616-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1>To iterate is human, to recurse divine.</h1>
  
    <h2><a href="/">金皆</a></h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:isaachan.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/aboutme.html">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/">Scheme on Prolog (4)：运行时环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-04T09:49:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在，我们已经用Prolog实现了范例Scheme语言的<a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">源代码读取</a>、<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>和<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">语法分析</a>的部分，并且获得了AST。最后，我们要实现一个Scheme的运行时来消费AST，生成最终的计算结果。</p>

<p>当解析器生成了抽象语法树(AST)后，运行时环境可以对它进行处理，计算语法树表达的数值。如果代码只是如下简单的四则运算，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">Scheme on Prolog (3)：文法分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-04T09:49:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">上一篇文章</a>中，我们完成了词法分析，从源代码文件中获得了词法单元的序列。接下来，这些词法单元会被送到文法分析器中做进一步处理。我们知道，形式文法是由一组文法生成式组成的。一个生成式可能是这样子的，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='antlr'><span class='line'><span class="nl">IfStat</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">&#39;if&#39;</span><span class="w"> </span><span class="err">&#39;(&#39;</span><span class="w"> </span><span class="err">Expr</span><span class="w"> </span><span class="err">&#39;)&#39;</span><span class="w"> </span><span class="err">StateBlock</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>这是常见的描述if语句的生成式，它表达了这样的含义：如果匹配了‘if’，并且匹配了&#8217;(&#8216;，并且匹配了Expr，并且匹配了&#8217;)&#8217;，并且遇到了StateBlock，那么就匹配了一个完整的IfStat。这里我故意使用了“如果”、“并且”、“那么”，目的是想说明文法生成式和Prolog语句是有着惊人的相似的。每一个生成式实际上就是一个命题。因此，相对于命令式语言，用Prolog进行文法解析是一件比较简单的工作。下面，我们开始用Prolog实现简单Scheme的文法分析部分。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">Scheme on Prolog (2)：词法分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-04T09:49:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上一篇“<a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">读取源文件</a>”的文章中，我们实现了readFile谓词，利用它可以读取源文件的内容，并把字节流保存在一个整数的列表中。接下来我们将消费这些数据，通过它们创建词法单元。因此，本节将讲述如何构造一个词法分析器来完成这件事。</p>

<h2>词法分析</h2>

<p>就像在第一节已经指出的，本文处理的只是Scheme的子集，它的词法规则如下：</p>

<ul>
<li>+, -, *, /, (, ),Whitespace</li>
<li>&#8216;define&#8217;</li>
<li>identifier number</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">Scheme on Prolog (1)：读取源文件</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-02T22:53:00+08:00" pubdate data-updated="true">Oct 2<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在接下来的一系列文章里，我将详细讲述如何利用Prolog，从零开始构造一个Scheme子集的<a href="https://github.com/isaachan/scheme-runtime">运行时环境</a>。这个运行时环境可以解释执行如下四则运算的Scheme代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，它还可以通过“define”定义变量，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>选择Scheme的原因在于它足够简单而且有趣。另外，通过实现这个简单的运行时环境，我们也可以领略Prolog的独特之处。Prolog作为应用最广泛的逻辑式程序设计语言，在描述文法生成式时具有很多语言无可比拟的优势；另外作为声明式语言，Prolog不必描述运算的细节（甚至语句执行的顺序），因此程序的可读性比命令式语言要好很多。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/20/cipher-behind-https/">HTTPS背后的加密算法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-20T19:03:00+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当你在浏览器的地址栏上输入https开头的网址后，浏览器和服务器之间会在接下来的几百毫秒内进行大量的通信。InfoQ的这篇<a href="http://www.infoq.com/articles/HTTPS-Connection-Jeff-Moser">文章</a>对此有非常详细的描述。这些复杂的步骤的第一步，就是浏览器与服务器之间协商一个在后续通信中使用的密钥算法。这个过程简单来说是这样的：</p>

<ol>
<li>浏览器把自身支持的一系列Cipher Suite（密钥算法套件，后文简称Cipher）[C1,C2,C3, &#8230;]发给服务器；</li>
<li>服务器接收到浏览器的所有Cipher后，与自己支持的套件作对比，如果找到双方都支持的Cipher，则告知浏览器；</li>
<li>浏览器与服务器使用匹配的Cipher进行后续通信。</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/07/20/cipher-behind-https/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/28/cd-2013-2014/">展望2014，马上持续交付</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-28T16:54:00+08:00" pubdate data-updated="true">Jan 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>写这篇博客的时候，农历马年的步伐已经进入倒计时了。很多人都许了愿，“马上有钱”，“马上有对象”。那么，作为处在IT交付核心的我们，还应该再加一个愿望：马上持续交付。</p>

<p>在快速变化的IT行业里，四年是个相当长的时期，很多技术都在这段时间里走完了它的生命周期。从“持续交付”第一次走入行业的视野，到今天大概也就4年的样子，然而它不但没有褪色，反而逐渐受到越来越多的关注了。我们看到，不但越来越多的<a href="https://www.facebook.com/video/video.php?v=10100259101684977&amp;oid=9445547199&amp;comments">互联网</a>企业开始实施了持续交付，很多传统行业，比如金融、保险、电信等等，也都踏入了持续交付之路。我们都知道，持续交付涉及到软件交付的整个生命周期，那么，我们不妨来看一看，哪些因素让持续交付在今后几年里将会得到越来越多的关注。</p>

<h2>市场竞争带来业务驱动力，精益创业引爆持续变革</h2>

<p>如果找一个发展持续交付的“root cause”，市场这只看不见的手绝对当知无愧。两年前开始流行的“精益创业”告诉我们，快速地提供满足最终用户需求的产品，是企业生存之道。对于初创公司，能够比竞争对手提早进入市场，将会获得更大的优势，取得更好的发展前景。传统行业也没有什么可幸运的。它们也面对同样的竞争压力，还要承受自身改变的阻力。我们正在帮助一家跨国金融企业实施持续交付，将它们新产品的发布周期从六个月降低到两周。我们也有来自其他领域的客户，比如保险、电信，为了赢得市场上的竞争，获得更大的生存空间，都在不同程度上迈向了持续交付。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/01/28/cd-2013-2014/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/18/slide-textuality-tips/">文本化的幻灯片 - 实用技术</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-18T21:56:00+08:00" pubdate data-updated="true">Aug 18<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>不久前在博客上发了一篇使用Slideshow创建幻灯片的<a href="http://isaachan.github.io/blog/2013/08/17/slide-textuality/">文章</a>，不过这篇博文却是在两年多前写的。这两年多里，我在公司内部的演讲幻灯片几乎都是用Slideshow做的，外部演讲也用过几次了，比如<a href="http://www.lisp.org.cn/wiki/lisp/event/2013-meetup">Lisp社区的</a>。在这个过程中，我对Slideshow的强大功能与高效率越来越有信心了。这篇文章分享一些我总结的经验。</p>

<h2>1. 关于使用</h2>

<p>Slideshow本身要求使用者编写scheme代码来创建幻灯片，不过这部分不设计代码，而是一些方便使用的技巧。</p>

<h4>显示下一页预览</h4>

<p>在幻灯片演示的过程中，按住Alt-c（或者Cmd-c）可以开启、关闭下一页幻灯片的预览。图1显示了启动预览时的效果。
<img src="/images/slide-textuality-tips/slideshow-preview.png" alt="下一页预览" />
图1</p>

<h4>显示注释</h4>

<p>在幻灯片演示的过程中，按住Alt-d（或者Cmd-d）可以显示、隐藏注释内容。至于在幻灯片里添加注释的内容，需要调用comment函数，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">comment</span> <span class="s">&quot;this is a comment&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/18/slide-textuality-tips/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/17/slide-textuality/">文本化的幻灯片 - Slideshow</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-17T22:12:00+08:00" pubdate data-updated="true">Aug 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>作为一名体面的程序员，作为一名被Unix文化侵染的程序员，作为一名希望世界是由简单的纯文本构成的程序员，生活中充满太多无奈。二进制的格式无处不在，后缀名将文件分出了三六九等。这其中，有两种文件我最无奈，图像和幻灯片，它们总和我的工作生活密切相关。</p>

<p>不过，现在光来了！HuKai在一篇<a href="http://www.iamhukai.com/?p=149">blog</a>里介绍了一个很酷的工具——Dot，它提供了一种可以基于文本描述图形的简洁的DSL。利用这个DSL，可以绘制出相当复杂的图案。激动之余，我开始寻找文本化幻灯片的方法。于是，我发现了DrRacket（它的前身就是大名鼎鼎的DrScheme）。DrRacket是MIT开发的Scheme的运行时，其中包含一个制作幻灯片的组件，名曰Slideshow。</p>

<p>很明显，Slideshow要求使用者用scheme来编写幻灯片，这就满足了像我这样的语言控的怪癖。我也因此放弃了一些其他类似的工具，比如SliTex。在Slideshow中，最核心的概念是pict和slide。slide自然表示一张幻灯片，它是由一个或多个pict按照不同的顺序排列组成的。slideshow的源代码以rkt为后缀名。下面是Slideshow的Hello World（hello.rkt）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="o">#</span><span class="nv">lang</span> <span class="nv">slideshow</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">slide</span> <span class="p">(</span><span class="nf">t</span> <span class="err">“</span><span class="nv">Hello</span> <span class="nv">World</span><span class="err">”</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/17/slide-textuality/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/07/chocolatey-i-love-you/">Chocolatey, 我爱你</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-07T14:28:00+08:00" pubdate data-updated="true">Feb 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>巧克力在很多文化里都代表了美好的事物。如果你是Windows的使用者，可能Windows复杂、丑陋的包管理正在把你折腾的很惨。*NIX平台上的各种优雅的包管理工具这时让人非常眼馋。直到有一天Chocolatey出现了，让我看到了Windows平台上的包管理朝着正确的方向前进了。看来，和巧克力沾边的东西都能让人产生幸福的感觉。</p>

<h2>1. 安装</h2>

<p>Chocolatey的安装过程简单至极，在<a href="http://chocolatey.org/">Chocolatey.org</a>上最醒目的地方有一行命令，把它复制到命令行中运行，只要一分钟左右，安装就完成了。在命令下键入</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">chocolatey</span> <span class="n">help</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以验证安装是否成功。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/02/07/chocolatey-i-love-you/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/31/about-ideal/">关于理想</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-31T22:22:00+08:00" pubdate data-updated="true">Jan 31<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>理想这个东西，刚刚带上总会让人受伤。</p>

<p>但是时间长了以后，它却像鸦片一样，成为你生命里离不开的东西。你每天就为了它而奔波。</p>

<p>你懂的。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'isaachan';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
