---
layout: post
title: "[翻译] 使用Prolog开发新语言"
date: 2013-02-03 12:44
comments: true
published: false
categories: 
 - prolog
 - erlang
 - joe armstrong
 - 翻译
---

## 概述 ##
这篇论文讲述了如何利用Prolog开发一个全新的并发实时符号程序设计语言，也就是后来的Erlang。

Erlang的第一个原型是由Prolog开发的——这个原型曾交给一个用户组使用，并收集他们对新语言的反馈。随着时间流逝，解释器被增增删删了无数特性，终于达到了一个成熟级别，可以用于一些关键领域了。

在以后的3年里，人们大约写了20000行Erlang代码，这时性能成为问题了——我们写过Prlog交叉编译器，编译Erlang以及各种并发逻辑程序设计语言。Erlang的实现不严格地基于WAM，它包含一个Prolog的编译器，将Erlang编译为新的抽象机的指令，还包含一个C开发的模拟器。抽象机的指令集最初是用Prolog创建的原型——最后编译器用Erlang重写了，从而彻底移除了对Prolog的依赖。

这篇论文讲述了Erlang从一个简单原型发展到当前版本的过程中，发生的一些关键的事件。

## 1. 简介 ##

本论文讲述了Erlang语言的开发[AR90]。

当时没有意识到，但是我们无意中遵从了Brooks的建议[BR86]，他坚持软件系统应该渐进地发展，而不应按照传统的方式来设计，这种快速原型的方法应该成为设计方法论。

我们本来没打算开发新语言，只是想尝试寻找一种优雅的方式为简单的电信应用编写PABX（Private Automatic Branch Exchange）, Erlang不过是过程中的副产品。［DA86］记录了一些基础性的工作，[AR86]记录了一些最初的语言实验的结论。

在撰写本论文的过程中，我们还遵从了Parnas和Clements的建议[PA86]，也就是，我们将新语言作为一种理性设计的结果来展示——实际上真正的设计过程几乎是无法描述的。

开发能够取得的成功在很大程度上是因为我们采用了Prolog（确实，如果不是Prolog，不知道Erlang这样的语言还能不能出现）。Prolog提供的交互环境让我们在开发过程中可以快速地变化。从更细节的层面上讲，Prolog的实现给我们提供了关键的灵感，让我们创造了今天的Erlang。Prolog自身的**错误**也警告我们在开发Erlang时应该避免什么。

Erlang支持的一些机制是Prolog所没有的。Erlang是并发、实时、分布式的函数式语言，适合构建大型的嵌入式实时系统。它包含很多模块，可以创建大规模的系统，在运行时系统中，代码可以随时更改，并且有一套成熟的错误捕获机制，这些都保证了Erlang可以用于构建高度健壮的软件系统。[AR89，AR90]包含了关于Erlang的更好细节。

最初Erlang只是一个简单的Prolog元解释器，然后我们给它添加了并发和错误处理机制的概念。最终，Erlang成为了一门独立的语言。在第二节中，我们将详细描述Erlang解释器背后的理念。

当构造了一个简单的Erlang解释器后，我们就迫不及待地用它解决真实的问题了。有一组程序员使用它对真实的电信应用进行建模。其中一些成果被记录在[PE91]中。

第三节记录了用户组对于语言开发的影响。

随着语言的发展，它获得了自己的语法和它与Prolog缺陷之间的联系——第四节讲述了语言的开发。

迄今为止，开发过程是极度不正规的——解释器（几乎每天在变）是语言唯一的定义。当解释器成熟时，并且变化不再频繁后，适当的文档就是必须的了。这个变化将在第五部分讲述。

大概三年后，用户组对这门语言感到满意了。其中一项研究曾使用Erlang编写了20000行代码，实现了电信交换系统中的某些特性。这些特性曾经用传统的语言实现过。使用Erlang后，可以减少7到22倍的工作量。现在，语言的性能成为了主要的关注点。尽管大家对于语言强大的表现力非常满意，但是他们还需要一个比现有解释器至少快40倍实现。

第六节讲述了我们让语言更快的一些尝试。第一个尝试是将Erlang交叉编译为Prolog或者STRAND。

对于下一阶段开发的灵感来自于WAM[WA83]——由于Erlang源自于Prolog，所以试Prolog变快的技术理所应当地也适用于Erlang。我们将讲述如何实现一个更快的Erlang。

第七节描述了语言当前的状态。

## 2. 第一版解释器 ##

首先，让我们从开发一个简单的Prolog解释器开始。它能够运行非常有限的Erlang子集。

第一个解释器是个简单的Prolog元解释器，并在Prolog的基础上增添了可中断进程的概念。这个解释器只是个起点，而我们的目标是寻找适合开发健壮、并发实时系统的语言。接下来还进行了一系列的试验，来检验这个语言应该包含哪些特性。

我们对这个解释器进行快速地修改（和重写），为了加入在认真的研究过程中确定下来的功能。这些研究的目的是为了探索电信领域程序设计语言应有的特性[DA86]。

在那段时期里，解释器可以在几天里全部被重写，或者在几个小时内就做个简单的扩展。

在下面几节中，我们解释这个解释器用到的几项基本技术。

### 2.1 中断计算 ###

第一步是实现**可中断的**计算。我们希望编写一个元解释器，可以在任何时间点中断，稍后也可以重新**恢复**计算。

看一下Vanilla解释器中solve/1的实现如下：

{% codeblock lang:prolog %}
solve((A,B)) :-
      solve(A), solve(B).
solve(A) :-
      bulitin(A),
      call(A).
solve(A) :-
      rule(A, B),
      solve(B).
{% endcodeblock %}

对于程序员来说，计算的中间过程是不可访问的。目标solve/1的停止条件是获得答案，当计算进行时，我们不可能中断它。

实现可中断计算的最简方法是，将所有未解决的（unsovled）目标存入一个列表，再一个接一个地从列表中取出头元素，解决（solve）它，然后解决列表中所有剩余的目标。在解决目标的过程中，可能会生成一个或多个新的目标，那么把这些目标添加到列表的头部。下面的代码可以达到上述目的：

{% codeblock lang:prolog %}
reduce([]).
reduce([{X}|T]) :-
      call(X),
      !,
      reduce(T).
reduce([Lhs|More]) :-
     eqn(Lhs, Rhs),
     append(Rhs, More, More1),
     !,
     reduce(More1).
{% endcodeblock %}

上面的代码能够归并形如[Item1, Item2, …]的列表。这里假设由花括号“｛”和“｝”括起来的部分是Prolog内建的目标，其他的则是用户自定义的规则。

作为例子，我们来看一下两个常见的函数：reverse和factorial是如何用eqn/2的风格实现：
{% codeblock lang:prolog %}
eqn(nrev([H|T], Z), [nrev(T, T1), concat(T1, [H], Z)]).
eqn(nrev([], []), []).

eqn(concat([H|T], T1, [H|T2]), [concat(T, T1, T2)]).
eqn(concat([], T, T), []).

eqn(fact(0, 1), []).
eqn(fact(N, F), [{N1 is N - 1}, fact(N1, F1), {F is N * F1}]).
{% endcodeblock %}

reduce/1会按照预期行为运行：
    
{% codeblock lang:prolog %}
？- reduce([fact(3, F), {write(result(F)), nl}]).

result(6)

F=6 ?

.. 

?- reduce([nrev([a,b,c],R), {write(result(R)), nl}]).

result([c,b,a])

R=[c,b,a] ?

... 
{% endcodeblock %}


以fact为例，如果追踪reduce/1的完整执行信息，会得到下面的输出：

**从ps文件中copy**

在计算过程中，保留在列表中的目标可以随时被归并，因为这个列表只是一个Prolog数据结构，用户可以按照任何需要的方式操作它们。这里我们需要的是在完成固定数量的归并步骤后，将计算中断。

### 2.2 在固定数量的归并步骤后中断计算 ###
谓词reduce/3与reduce/1类似，不同点在于它在执行了固定数量的归并步骤后会中止。目标：

{% codeblock lang:prolog %}
reduce(GoalList, Reductions, Result)
{% endcodeblock %}

会归并GoalList中的目标，并最终将Result绑定为terminated(N)或者continuation(More_Goals)。terminated(N)意味着计算在N步归并后就完成了；如果执行了20次归并后，目标列表中仍有残留的目标没有执行，则会返回continuation(More_Goals)。Reductions用来记录已经进行了多少次归并：

**从ps文件中copy**

举个例子，

**从ps文件中copy**

当然，我们可以重新执行余下来的计算步骤，

{% codeblock lang:prolog %}
continuation(New_Goals), reduce(New_Goals, 0, Result1)
{% endcodeblock %}

### 2.3 多任务调度器 ###

我们可以以前一节的归并机制为基础，实现一个简单的“Round Robin”调度器（multi_reduce/1）。它以形如job(N, Goals)的任务（Task）列表作为参数。调度器允许每个任务最多执行20步归并，然后进入下一个任务，直到所有任务全部完成。N是任务的名字，Goals是任务中包含的目标列表。

**从ps文件中copy**

为了方便观察程序的行为，可以加入一些write语句：

**从ps文件中copy**

观察输出，我们能够看到三个目标nrev([a,b,c,d,e,f,g,h])，nrev([1,2,3,4,5], R1)和fact(10, Fact)在并发执行。

这是一种伪并发，因为我们只有一个处理器。任务执行一定数量的归并后被中断，这个行为模拟了时间片，以及进程的任务切换、上下文切换。每个独立线程的计算模拟了一个进程。

### 2.4 函数式风格的解释器 ###

我们暂时先忽略上下文切换的话题，还是回到一个基本的归并上来。我们定义一个新的reduce1/1，让它支持更有函数式风格的编程：

**从ps文件中copy**

注意，对于这个本版的解释器支持的元语言，write/1和nl/0已经成为原语函数了，可以直接调用它们，不再需要花括号括起来了。添加其他的原语也非常容易，和write/1和nl/0非常类似。

再回到前面fact和reverse的例子，现在可以这样写：

**从ps文件中copy**

以及

**从ps文件中copy**

### 2.5 带有进程和消息传递的函数式语言 ###

这是最后一个，也是最复杂的示例。我们将综合前面两节的想法，编写一个reduce2/4解释器，它支持函数式编程风格、创建进程、进程间传输简单的消息。

每个进程都是一个数据结构：job(Id, Goals, MailBox)，Id是进程名，Goals计算中包含的未解决的目标列表，MailBox是一个消息的列表，里面包含由其他进程发送的且还没有被该进程接收的消息。

目标reduce2(Goals, Id, MailBox, Jobs)代表一个简单的多任务操作系统的当前状态。Goals，Id和MailBox表现了当前的执行进程，Jobs是所有被中止的进程的列表。我们将这些进程成为“环境”。

**从ps文件中copy**

元语言的原语spawn(Id, Goals)会调度一个新的进程，名字是Id，目标列表是Goals，send（Id， Message）会将消息Message发送到名为Id的进程。receive函数可以返回进程邮箱中的第一个值。

这个简单的解释器所用的调度算法也非常简单，一个进程停止执行的条件只有两个：要么它终止了，要么它试图接收（receive）消息时，邮箱中却是空的。

在实际情况下，我们会使用更加复杂的调度算法，它将包含时间片，以及当进程停止执行时进行的上下文切换。

**从ps文件中copy**

相应的eqn2/2定义了一个新的元语言——如下是用这个元语言写的简单程序：

**从ps文件中copy**

这段程序创建了两个进程，分别是sender和catcher。sender向catcher发送五条消息，然后终止。catcher接收这些消息，并在收到终止消息“stop”的时候终止运行：

**从ps文件中copy**

### 2.6 解释器特性小结 ###

前面几节中实现的解释器展示了如何使用Prolog构造一个基于进程的计算模型。这个解释器有很多不妥的地方，其中元语言对用户不友好，任何元语言中的错误都会导致解释器以各种怪异的方式崩溃。

另外我们完全没有考虑性能的问题——真实的解释器会使用difference list来消除程序中的append，这样性能或多或少会有些改善（但是却牺牲了可读性）。

早期阶段的语言特性可以在数小时内实现——讨论语言特性的时间永远比实现特性花的时间长。在语言解释器的开发阶段，它经历了无数次的细小变化，以及一些重大的修改——这通常意味着完全重写。

解释器本身被证明是健壮的、高度可移植的。第一版是在VAX 11/750上使用NU Prolog实现的，紧接着移植到到同一台机器上的Quintus Prolog系统上。后来用户组的成员们转到PC上，所以又出现了PC/AT上的ALS Prolog版本。我们又把它迁移到SICStus Prolog，运行环境也从VAX转到了SUN3/60和SPARC。

上述这些Prolog版本、计算机平台的变化并没有产生什么不好解决的大问题。我们遇到的操作系统不兼容性的问题（尤其是MS-DOS和UNIX）远多于不同的Prolog系统之间的问题（尽管如此，Prolog仍然不是一个标准化的语言）。

利用2.1到2.5节描述的技术和4.1节描述的语法，我们实现了第一版并发语言的解释器——语言包含下列特性：

 * 并发进程
 * 选择性消息传递
 * 进程组
 * 基于进程组错误信号和捕获机制
 * **内联**Prolog代码
 * 时间片
 * Round Robin调度机制
 * 追踪跨进程消息
 * 独立进程调试
 * I/O虚拟通路（Port）

实现这些特性大约需要1100行Prolog代码。

第一个解释器用来实验各种不同的语言构件、调度机制和编程风格等等，目标是找到一种方便的、简单的、优雅的方式来解决电信领域编程问题。

实验室在一台由Prolog解释器控制的Ericsson MD110 PABX [MD82]（Private Automatic Branch Exchange）上进行的。

在实验进行期间，我们几乎每天都在快速地修改解释器、元语言和元语言编写的程序。过了一段时间后，我们对手头的编程风格和解释器充满自信，相信它能在更大的领域里发挥作用。

## 3. 用户组 ##

随着第一版解释器稳定下来，第一个用户组也诞生了。这个组的成员来自于应用开发程序员（不属于计算机科学实验室（CSL）），他们对创建小型PABX的新架构、新语言很感兴趣。

用户组的形成过程促进了开发过程的稳定性。CSL成员必须在一定时间内交付可用的、包含文档的软件，实现用户组的想法。

在历时一年的时间里，CSL和用户组成员每周见一到两次面，以沟通彼此之间的问题——这个过程的价值难以言表：使用者拥有无与伦比的应用开发经验，因此提出了很多有价值的语言特性（而且把它们添加到解释器中非常简单）。CSL成员会说服应用开发者，告诉他们为什么有些特定的命令式编程风格会产生问题，从而应该避免。

这个过程虽然有时候会令人沮丧，但是后来回顾的时候，我们认为发现这是一个关键的因素，得以让这个语言后来拥有足够的接受度。

有一点非常有趣，一旦用户组开始使用语言，语言就又开始变化了。它经历了两次大的变化，一次是为了满足CSL内部开发者的需要，另一次是为了满足用户组的反馈。

## 4. 语言开发 ##
### 4.1 语法开发 ###
我们仍以reverse和factorial为例。在2.4节中，它的语法如下，

**从ps文件中copy**

通过新定义的中缀操作符--->，我们可以忽略functor符号eqn1:

**从ps文件中copy**

上述的语法是真实用户面对的第一版语法。该语法的缺点是错误信息、运行时诊断消息都是以Prolog数据结构表现的，不是Erlang自己的。

在这个语言被使用了一年后，达到了相对稳定的状态，于是我们写了Erlang的解析器，为语言自身赋予了语法，这样我们也可以摆脱Prolog的舒服，创造新的语法和结构。

上面的代码用新语法可以写成这样：

**从ps文件中copy**
 
有了新语法后没多久，我们就转向了纯函数式的风格，避免了不必要的临时变量，上面的代码可以这样写：

**从ps文件中copy**

上述每种语法的开销如下：

 * 原有的Prolog子句：0行Prolog代码
 * 中缀操作符--->需要添加读取Erlang函数并将它转化为标准形式的代码——91行Prolog代码
 * 用Prolog实现解析器：1057行Prolog代码（629行是解析器，262行是词法分析，166用于格式化输出）

解析器最初是用Prolog DCG实现的，但是使用DCG的想法迅速被放弃了，因为担心这种方式无法提供有意义的、精确的错误诊断信息。最后的方案是将Erlang文法完全展平成LL(1)文法，然后为它写一个传统的递归下降解析器。同时，这样做也就剥夺了用户自定义中缀操作符的可能。

### 4.2 新语法带来的语言变化 ###

引入了完全可解析版本的新语言后，还增加了下面的新特性：

 * Tuple（写作{Item1,Item2,Item3, ...}）用来存储固定数量的元素
 * 零参数的函数可以写为func()，不过同名的atom不需要括号
 * 模块系统
 * 函数看守（guard）

## 5. 语义内嵌 ##

从Prolog到新语法的转化并不仅仅是表面样子的变化。因为它已经不再是Prolog了，因此我们可以更多地从语言构件意义的角度来考虑问题，而不用再考虑它们被翻译为等价的Prolog代码后语句是什么。

很多时候，一个Erlang表达式的语义并不是精心设计后的结果，而是用Prolog实现时的意外所得。我们称这种现象叫做“**语义内嵌**”——Prolog的语义很意外地嵌入到Erlang中了。

我们在写Erlang解释器的时候就意识到这种现象了，后来在写编译器的时候，我们必须移除所有对Prolog的依赖。

举个例子，考虑下面的Erlang表达式：

{% codeblock lang:erlang %}
f(X, Y) ->
    Z = 3 * X + Y + 4 * 6 - X,
    ...
{% endcodeblock %}

解释器会将它翻译为下面的Prolog代码：

{% codeblock lang:prolog %}
...
Z is 3 * X + Y + 4 * 6 - X,
...
{% endcodeblock %}

于是，Erlang的算数表达式的**含义**是由相应的Prolog表达式的**含义**定义的。

当我们写Erlang解析器的时候，一定要定义算数表达式的文法，这时必须考虑我们是否要遵循Prolog的算数表达式文法，或者使用其他不同的文法。

用Prolog编写解释器还产生了另一个意外的效果，就是最初的Erlang的所有变量都是Prolog的逻辑变量。

最终我们认为Erlang中包含Prolog的那种逻辑变量会引入一些不好的特性，原因在于一旦在两个进程之间发送包含逻辑变量的消息后，进程间就可以以一种**不可见的**机制（变量绑定）进行通讯，而不是使用消息传递——我们希望所有跨进程通讯的行为都是通过消息传递的方式显式地完成的。

## 6. 定义文档 ##

Erlang最初只是个简单的Prolog元解释器。那时解释器就是语言的定义。语言本身没有文档，它完全通过解释器来定义。

后来我们才开始撰写手册、参考和指南等等。由于语言处在快速的变化中，所以手册与解释器之间经常对不上。在早期开发阶段，如果解释器和手册不同，那么解释器是对的，手册是错的，这样对于任何关于语言的问题，我们都可以回答：试一试然后看结果。

当语言成熟以后，这种方法就迎来了一个转折点，当语言和手册不同时，手册是对的，而语言实现是错的。在这个阶段，我们花了很大力气来保证手册是正确的——这非常困难，尽管Prolog系统能够对解释器进行细致的校对，但是没有任何办法能够确保手册的正确性！——（这绝对和一种传统的实践相反，这种实践说应该先定义文档，再写实现。我们的方法更简单——相对于想象一些不存在的东西的属性，描述一些已经存在的事物更加简单！）。

当定义文档的关注点从解释器转到手册时，反映了语言的成熟度到达了一个新的水准。

## 7. 性能 ##

开始关注性能问题本身是阶段的一个里程碑。我们进入了一个新的阶段，此时虽然还是关注实现，但是可以不再改变语义，只对语言的性能感兴趣。

第一个想法是交叉编译，将Erlang变成一个并发逻辑式编程语言，这是非常自然的想法，因为我们所做的一切都是在Prolog中添加了并发的概念，而在逻辑式语言中，并发是免费的！

于是我们开发了并不严格基于WAM[WA83]及其后裔的实现。

### 7.1 交叉编译为并发逻辑式编程语言 ###

我们首先尝试了用Prolog编写交叉编译器，从Erang编译为Prolog[CL84]和STRAND[FO89]——后来基于STRAND的实现的效率比Prolog解释器快一些，但仍然没有满足我们的预期。

[FO89]的第十三章详细地讲述了交叉编译的过程。这个过程將所有Erlang的Arity N函数编译为Arity N+8的STRAND目标。然而，生成的程序仍然没有到达我们希望的性能。

在编译为STRAND这类语言的过程中，我们遇到了一些问题。我们的并发模型是不同的——Erlang在进程级别提供并发性，STRAND有更细粒度的并发，另外错误处理机制也不同。这些和其他一些问题迫使我们思考使用自己来实现编译器、运行时。

### 7.2 类WAM机器的编译器 ###

下一阶段的开发关注于构建一个高性能的Erlang机器。

STRAND和Prolog实现都巧妙地避开了一些麻烦的实现问题，有限时间的垃圾回收、实时调度等等。我们也要在第一个编译版本里面考虑这些问题。

编译版本的Erlang的想法来自于WAM——由于Erlang脱胎于Prolog，用于改进Prolog系统的技术很自然地可以用于Eralng。我们遇到的第一个困难是理解WAM，因为当时没有容易理解的WAM的描述（现在情况好多了[HA91]）。当我们读过[MA88]的第十一章后，才出现转折点。这本书清楚地描述了类WAM的机器。我们具备了足够的知识，可以实现我们自己的机器了。

我们编写了Erlang到我们的机器（JAM）的编译器以及JAM的模拟器。最初，编译器和模拟器都是用Prolog实现的。结果它们慢极了！(正常的是5 Erps (每秒Erlang归并), 追踪指令执行时只有0.5 Erps)——这样根本无法调试指令集或者调用帧栈的结构。主要的优势是我们能够借用Prolog底层的存储管理机制来写模拟器。

当完成了指令集和机器架构后，我们用Erlang重写了编译器，并用‘C’重写了模拟器。经过了三次彻底重写之后，这个版本比原始的Prolog解释器快了70倍。

[AR91]中囊括了语言实现的更多细节，包括JAM的细节、虚拟机的指令寄存器和并发机制的实现。

## 8. 当前状态 ##

Erlang现在是编写实时软件的绝佳语言。有三种完整的实现，一个是用Prolog，其他两种是独立的类WAM实现。

在写本文的时候，Erlang被用于30个项目，并且以每月1-2个项目的速度增加——它被用于大量的原型开发，以及少量的内部项目。

Erlang语言对于非商业使用是免费的（erlang@erix.ericsson.se获取更多信息）。

感谢 & 引用 （略）

