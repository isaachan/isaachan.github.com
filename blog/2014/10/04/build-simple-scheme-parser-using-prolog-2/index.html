
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Scheme on Prolog (2)：词法分析 - To iterate is human, to recurse divine.</title>
  <meta name="author" content="">

  
  <meta name="description" content="在上一篇“读取源文件”的文章中，我们实现了readFile谓词，利用它可以读取源文件的内容，并把字节流保存在一个整数的列表中。接下来我们将消费这些数据，通过它们创建词法单元。因此，本节将讲述如何构造一个词法分析器来完成这件事。 词法分析 就像在第一节已经指出的，本文处理的只是Scheme的子集， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2">
  <link href="/favicon.ico" rel="icon">
  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="To iterate is human, to recurse divine." type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42344616-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1>To iterate is human, to recurse divine.</h1>
  
    <h2><a href="/">金皆</a></h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:isaachan.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/aboutme.html">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Scheme on Prolog (2)：词法分析</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-04T09:49:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>在上一篇“<a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">读取源文件</a>”的文章中，我们实现了readFile谓词，利用它可以读取源文件的内容，并把字节流保存在一个整数的列表中。接下来我们将消费这些数据，通过它们创建词法单元。因此，本节将讲述如何构造一个词法分析器来完成这件事。</p>

<h2>词法分析</h2>

<p>就像在第一节已经指出的，本文处理的只是Scheme的子集，它的词法规则如下：</p>

<ul>
<li>+, -, *, /, (, ),Whitespace</li>
<li>&#8216;define&#8217;</li>
<li>identifier number</li>
</ul>


<!-- more -->


<p>第一行列出的词法单元只包含一个字符，第二行的‘define’是一个关键字，虽然它不是一个字符组成的，但是仍然是固定长度的。第三行的identifier和number是标识符和数字，它们几乎出现在所有语言中，并且它们的长度不是固定的。</p>

<p>很明显，第一行中的词法单元是最容易识别的，下面这些谓词描述如何识别它们：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">40</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">lp</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="p">(</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">41</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">rp</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="p">)</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">42</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">mult</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">*</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">43</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">plus</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">+</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">45</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">minus</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">-</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">47</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">div</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">/</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">32</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">9</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">10</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码实现了getToken谓词，这个谓词的第一个参数是进行词法单元匹配以前的字节流，第二个参数是匹配过词法单元后剩余的字符流，第三个参数表示此次getToken匹配到的词法单元。代码中出现的整数，40，41，42&#8230;是字符的ASCII码，后面的注释解释了它代表的字符。上述代码中的[40|Rest]的词法单元是一个列表，它的第一个元素是40，其他元素是Rest。这很类似于scheme中的car和cdr操作。[]则表示一个空的列表。Prolog的这种文法极大的方便了列表的处理。如果你熟悉Erlang，会发现它和Prolog处理列表的文法和语义是一样的（事实上这两种语言也确实深有渊源！）。</p>

<p>接下来，我们看看如何识别define关键字。由于这个词法单元的长度是固定的，因此识别它也并不复杂：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">100</span><span class="o">,</span><span class="mi">101</span><span class="o">,</span><span class="mi">102</span><span class="o">,</span><span class="mi">105</span><span class="o">,</span><span class="mi">110</span><span class="o">,</span><span class="mi">101</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">define</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">define</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们用到了列表的另一种文法，[100,101,102,105,110,101|Rest]表示列表的前六个元素一次是 100,101,102,105,110,101。因此这个谓词可以匹配define。</p>

<p>现在我们已经可以匹配除标识符和数字以外的其他词法单元了，那么如何把所有匹配到的词法单元收集到一起呢？嗯，我们需要一个getTokens谓词来收集词法单元，如果输入的字节列表为空，那么收集工作宣告结束；否则，它应该能重复地调用getToken，前一个getToken的输出是后一个getToken的输入。哦，对了，Prolog没有for循环，用递归才能实现重复执行一段代码的工作。OK，getTokens谓词的代码应该是这样子了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getTokens</span><span class="p">([]</span><span class="o">,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">reverse</span><span class="p">(</span><span class="nf">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">OneToken</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="p">[</span><span class="nv">OneToken|TokensSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>TokensSoFar用来收集计算过程中匹配的词法单元，但是它收集的顺序和词法单元真正的顺序是相反的，因为geTokens总是把后遇到的词法单元放到TokensSoFar的头部，这是受到Prolog列表处理的限制。当输入字节流为空时，把TokensSoFar中的词法单元反向排序，就得到了我们想要的答案。</p>

<p>在进行词法分析的过程中，我们通常要丢弃一些无用的词法单元，比如注释、空白符等等。我们的Scheme子集不支持注释，所以这里我们只要丢弃掉空白符即可。当getTokens遇到一个ws词法单元的时候，不要把它加到TokensSoFar的头部，而是直接忽略掉：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getTokens</span><span class="p">([]</span><span class="o">,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">reverse</span><span class="p">(</span><span class="nf">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">OneToken</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="p">[</span><span class="nv">OneToken|TokensSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个getTokens谓词的位置很重要，它必须位于原来两个谓词之间。Prolog在模式匹配相同签名的谓词的时候，会按照它们声明的先后顺序进行尝试，因此必须把描述特殊情况的谓词排在前面，一般情况的谓词排在后面。</p>

<p>词法分析完成了吗？不不，我们还没有实现匹配标识符和数字的谓词！标识符和数字稍微复杂一些，它们的长度不是固定的，因此在匹配它们的getToken谓词中，还需要多一个参数，用来临时保存计算过程中已匹配的字节。在实现getToken之前，先看一下描述数字的自动机，</p>

<p><img src="/images/scheme-parser-using-prolog/number-fsm.gif" alt="状态机" /></p>

<p>标识符的自动机和它是类似的。我们可以这样描述该自动机的行为：如果输入的第一个字节是数字，则进入number状态，并记录下这个数字；在number状态下，如果输入的第一个字节是数字，则继续追加该数字； 在number状态下，如果输入的第一个字节是字符，则是非法输入；在number状态下，如果输入的第一个字节是+ - * / ( ) Ws中的任何一个，则结束number状态，并完成一个number词法单元的识别。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="nv">D|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">Nubmer</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getNumberToken</span><span class="p">(</span><span class="nf">T,</span> <span class="nv">Rest,</span> <span class="p">[</span><span class="nv">D</span><span class="p">]</span><span class="o">,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getNumberToken</span><span class="p">([</span><span class="nv">D|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">T,</span> <span class="nv">Rest,</span> <span class="p">[</span><span class="nv">D|DigitsSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getNumberToken</span><span class="p">([</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">single</span><span class="p">(</span><span class="nf">H</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">reverse</span><span class="p">(</span><span class="nf">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span> <span class="nv">:-</span> <span class="mi">47</span> <span class="nv">&lt;</span> <span class="nv">D,</span> <span class="nv">D</span> <span class="nv">&lt;</span> <span class="mi">58</span><span class="o">.</span>
</span><span class='line'><span class="nv">single</span><span class="p">(</span><span class="nf">T</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">T=39</span><span class="c1">; T=9; T=10; T=40; T=41; T=42; T=43; T=45; T=47.</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个getToken谓词描述了从非number状态到number状态的转换。进入Number状态后，开始调用getNumberToken谓词。getNumberToken谓词有两个，分别处理digit和那些只包含一个字符的词法单元。出于简单的考虑，这段程序没有显式地处理遇到字母字符的情况（比如打印一段错误信息），那么，如果在number状态下遇到字母字符时，由于没有相应的谓词可以去匹配，程序同样无法成功运行。最后，在程序的第一行，Rest的值也不是根据它前面的参数确定的了。因为只有读取完所有连续的数字后，才知道Rest的起点在哪里。在第9行，Rest最终被确定下来。这里Rest之所以是[H|T]而不是T，因为当读到一个符合single谓词的字节时，意味着number读取结束了，而刚刚读到的这个字节还要留给下一个谓词去处理，不能在这里吞噬掉。</p>

<p>关于匹配标识符的谓词，和匹配number的谓词几乎一样，在这里就不多赘述了。本文后面会提供所有的源代码。</p>

<p>目前getTokens谓词需要三个参数，FileContent, TokensSoFar和Tokens。其中TokensSoFar的初始值必然是一个空的列表。因此，我们可以再创建一个谓词来“封装”这里参数，从而留给调用者一个更友好的API。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'>   <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">Tokens</span><span class="p">)</span>
</span><span class='line'>       <span class="nv">:-</span> <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="p">[]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，我们有file和getTokens两个谓词了，把它们写在一起已经可以分析指定文件的词法了。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">:-</span> <span class="nv">file</span><span class="p">(</span><span class="err">“</span><span class="nv">example</span><span class="o">.</span><span class="nv">ss</span><span class="err">”</span><span class="o">,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>   <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下了，将是更有挑战的工作——<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">文法分析</a>。</p>
</div>


  <footer>
    <p class="meta">
      
  



      








  


<time datetime="2014-10-04T09:49:00+08:00" pubdate data-updated="true">Oct 4<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/compiler/'>compiler</a>, <a class='category' href='/blog/categories/language/'>language</a>, <a class='category' href='/blog/categories/parser/'>parser</a>, <a class='category' href='/blog/categories/porlog/'>porlog</a>, <a class='category' href='/blog/categories/scheme/'>scheme</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/" title="Previous Post: Scheme on Prolog (1)：读取源文件">&laquo; Scheme on Prolog (1)：读取源文件</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/" title="next Post: Scheme on Prolog (3)：文法分析">Scheme on Prolog (3)：文法分析 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'isaachan';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/';
        var disqus_url = 'http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
