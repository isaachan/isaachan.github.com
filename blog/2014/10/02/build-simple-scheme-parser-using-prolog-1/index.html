
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Scheme on Prolog (1)：读取源文件 - To iterate is human, to recurse divine.</title>
  <meta name="author" content="">

  
  <meta name="description" content="在接下来的一系列文章里，我将详细讲述如何利用Prolog，从零开始构造一个Scheme子集的运行时环境。这个运行时环境可以解释执行如下四则运算的Scheme代码： 1
2
(+ 1 2)
(+ (- 5 3) (* 2 3)) 另外，它还可以通过“define”定义变量， 1
2
3
4
( &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1">
  <link href="/favicon.ico" rel="icon">
  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="To iterate is human, to recurse divine." type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42344616-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="no-sidebar"  >
  <header role="banner"><hgroup>
  <h1>To iterate is human, to recurse divine.</h1>
  
    <h2><a href="/">金皆</a></h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:isaachan.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/aboutme.html">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Scheme on Prolog (1)：读取源文件</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-02T22:53:00+08:00" pubdate data-updated="true">Oct 2<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>在接下来的一系列文章里，我将详细讲述如何利用Prolog，从零开始构造一个Scheme子集的<a href="https://github.com/isaachan/scheme-runtime">运行时环境</a>。这个运行时环境可以解释执行如下四则运算的Scheme代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，它还可以通过“define”定义变量，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>选择Scheme的原因在于它足够简单而且有趣。另外，通过实现这个简单的运行时环境，我们也可以领略Prolog的独特之处。Prolog作为应用最广泛的逻辑式程序设计语言，在描述文法生成式时具有很多语言无可比拟的优势；另外作为声明式语言，Prolog不必描述运算的细节（甚至语句执行的顺序），因此程序的可读性比命令式语言要好很多。</p>

<!-- more -->


<p>正如前面的代码所示，我们实现的解析器只能执行简单的四则运算，但是它却涉及到读取源文件、词法分析、语法分析和构造符号表等技术，这些是所有高级编译器都具有的功能。因此本文分为四个部分，分别讲述下面四个问题：</p>

<ul>
<li>读取源文件</li>
<li>词法分析</li>
<li>语法分析</li>
<li>运行时环境</li>
</ul>


<h2>读取源文件</h2>

<p>读取源代码文件是后续分析、解释执行的第一步。这个示例程序并没有提供交互式运行的机制，因此从文本文件中读取代码并运行是唯一的启动程序的方式。</p>

<p>谓词推演是Prolog解决问题的手段，无论待解决的问题看上去和谓词推演多么的不相关。不过，谓词推演是足够强大的，足以解决“读取文件内容”的问题。我们设计一个谓词，用来从最高的层次上读取文件的内容：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">file</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个谓词的含义是：当FilePath是一个文件路径，并且FileContent是该文件的内容时，这个谓词为真，否则为假。当然，如果我们只告诉这个谓词FilePath的信息，Prolog运行时会找到FileContent的值，使这个谓词为真。正是由于这一点，file谓词可以为我们读取文件的内容了。</p>

<p>为了实现这个谓词，我们还需要完成一些工作，比如如何获取Prolog运行时内部的文件句柄？如何从文件句柄中依次读取数据？如何知道是否读到了文件的尾部？</p>

<p>调用其他Prolog运行时内置的与文件相关的谓词，它们要能够获取文件句柄，并从句柄中依次读取文件字节。简单地查找Prolog的文档，不难发现下面两个内置的谓词：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">open</span><span class="p">(</span><span class="nf">+FilePath,</span> <span class="nv">+OpenMode,</span> <span class="nv">-Stream,</span> <span class="nv">+Options</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">get0</span><span class="p">(</span><span class="nf">+Stream,</span> <span class="nv">-Char</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>open谓词的第一个参数是文件路径，第二个是打开文件的模式，可以是read/write/append/update之中的一个，第三个是文件句柄，第四个是额外的选项，比如字符集、缓存大小等。get0的第一个参数是文件句柄，它通常是open的输出参数Stream，第二个参数是读出的字符。get0会维护访问文件的指针，当每次调用get0时，指针会自动向后移动，当到达文件尾部的时候，Char等于-1。有了这两个谓词，我们可以进一步实现file谓词，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">file</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">open</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">read,</span> <span class="nv">Stream,</span> <span class="p">[</span><span class="nv">eof_action</span><span class="p">(</span><span class="nf">eof_code</span><span class="p">)])</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Steam,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里增加了一个readFile谓词，它会把Stream中的字节流保存到FileContent中。谓词readFile的实现可以描述如下：如果从Stream中读取的字节是-1（即到文件尾），那么读取完毕；如果从Stream中读取的字节不是-1，那么把该字节追加到已经读取的序列中，然后递归地调用readFile。下面的代码反映了这一描述：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="mi">-1</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">reverse</span><span class="p">(</span><span class="nf">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Char</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="p">[</span><span class="nv">Char|ContentSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，我们首先为readFile增加了一个参数：ContentSoFar，用来保存在计算过程中收集的不完整的文件内容，当将文件全部读取结束后，再把ContentSoFar的内容反序排列后与FileContent进行合一。我们注意到在第二个readFile中，[Char|ContentSoFar]会导致先读取到字节后放到ContentSoFar序列的后端。这就是说，如果读取的文件内容是123abc，那么ContentSoFar最终的值将是[&#8216;c&#8217;, &#8216;b&#8217;, &#8216;a&#8217;, &#8216;3&#8217;, &#8216;2&#8217;, &#8216;1&#8217;]。因此在第一个readFile的最后，需要把ContentSoFar反序排列后再与FileContent进行合一。</p>

<p>另外，get0的文档提到了，它读取的字节是一个int数值，代表了这个字节的ASCII码。出于测试的目的，我们不想看到读出的内容是一串数字，那么可以用atom_chars谓词将数字串转化为字符串，并使用write谓词将它输出到控制台上：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">display</span><span class="p">(</span><span class="nf">file</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">file,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">atom_char</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">FileContentChar</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">write</span><span class="p">(</span><span class="nf">FileContentChar</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在回过头来看看我们刚刚完成的readFile谓词，它的运行起来效果如何呢？我在尝试读取的文件如下文件：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">11</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>发现程序总是意外出错中止。检查了错误信息后，我发现它读取的内容是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">dfn</span> <span class="mi">1</span>
</span><span class='line'><span class="nv">+1a</span>
</span></code></pre></td></tr></table></div></figure>


<p>程序每读取一个字节会跳过一个字节。经过分析，我找到了错误的原因。当调用readFile谓词的时候，Prolog首先尝试第一个readFile的定义，即调用get0，并期望读到文件尾（-1），这当然是不成立的，于是程序回朔，继续尝试第二个readFile的定义。但是上一次失败已经改变了get0内部维护的文件指针，而且文件指针也不会随着回朔而改变，这就产生了我们前面看到的情况。每经由递归读取一个字节时，都要尝试第一个readFile的定义，而直到真的读取到了文件尾之前，它总是会失败而引起回朔，从而丢失一个字节。为了修正这个问题，需要如下修改我们的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Content</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A,</span> <span class="nv">Content</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">_,</span> <span class="mi">-1</span><span class="o">,</span> <span class="p">[])</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A,</span> <span class="p">[</span><span class="nv">A|Content</span><span class="p">])</span> <span class="nv">:-</span> <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Content</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，判断读取的字符是否为-1的任务下推给了readFile谓词，确保get0不会参与到回朔过程。另外，由于使用了不同的递归方式，新的实现可以直接读取正确顺序的文件字节流，不需要再次反序排列。</p>

<p>完成了读取源文件的工作，接下来我们就可以进行<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>了。</p>
</div>


  <footer>
    <p class="meta">
      
  



      








  


<time datetime="2014-10-02T22:53:00+08:00" pubdate data-updated="true">Oct 2<span>nd</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/compiler/'>compiler</a>, <a class='category' href='/blog/categories/language/'>language</a>, <a class='category' href='/blog/categories/parser/'>parser</a>, <a class='category' href='/blog/categories/prolog/'>prolog</a>, <a class='category' href='/blog/categories/scheme/'>scheme</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/07/20/cipher-behind-https/" title="Previous Post: HTTPS背后的加密算法">&laquo; HTTPS背后的加密算法</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/" title="next Post: Scheme on Prolog (2)：词法分析">Scheme on Prolog (2)：词法分析 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'isaachan';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/';
        var disqus_url = 'http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
