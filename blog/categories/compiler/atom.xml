<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: compiler | To iterate is human, to recurse divine.]]></title>
  <link href="http://isaachan.github.com/blog/categories/compiler/atom.xml" rel="self"/>
  <link href="http://isaachan.github.com/"/>
  <updated>2014-10-04T11:40:43+08:00</updated>
  <id>http://isaachan.github.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (4)：运行时环境]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4</id>
    <content type="html"><![CDATA[<p>现在，我们已经用Prolog实现了范例Scheme语言的<a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">源代码读取</a>、<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>和<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">语法分析</a>的部分，并且获得了AST。最后，我们要实现一个Scheme的运行时来消费AST，生成最终的计算结果。</p>

<p>当解析器生成了抽象语法树(AST)后，运行时环境可以对它进行处理，计算语法树表达的数值。如果代码只是如下简单的四则运算，</p>

<p>{% codeblock lang:scheme %}
(- 3 1)
(+ (* 3 5) 2)
{% endcodeblock %}</p>

<!-- more -->


<p>那么对AST遍历一次就足够了，甚至在解析的过程中就可以获得结果了，根本不需要生成AST。但是，我们希望这个运行时能够支持通过define定义变量，甚至变量的作用域是全局的，而不仅仅是从它声明的地方开始，</p>

<p>{% codeblock lang:scheme %}
(define a 1)
(+ a b)
(define b 2)
{% endcodeblock %}</p>

<p>上面这段程序的输出应该是3，而不是“b没有声明”的错误信息，因为define定义的变量的作用域贯穿所有的代码。对于这一要求，我们需要遍历两次AST，第一次构建符号表，第二次完成运算。在实际的开发中，我们会先完成第二步的功能，即先不考虑代码中存在变量的情况，然后在逐步地加入对变量的支持。</p>

<p>让我们呢先看看最简单的情形，求这个表达式的值</p>

<p>{% codeblock lang:scheme %}
(+ 1 2 3)
{% endcodeblock %}
按照前面的分析，解析器会生成下面的AST，</p>

<p>{% codeblock lang:scheme %}
[plus, 1, 2, 3]
{% endcodeblock %}</p>

<p>连续累加plus后面的元素，这需要一个简单的递归就够了：</p>

<p>{% codeblock lang:scheme %}
getValue([add, FirstOperand|OtherOperands], Result) :-</p>

<pre><code>getValue(FirstOperand, OtherOperands, Result).
</code></pre>

<p>getValue(ResultSoFar, [], ResultSoFar).</p>

<p>getValue(ResultSoFar, [H|T], Result) :-</p>

<pre><code>NewResult is ResultSoFar + H,
getValue(NewResult, T, Result).
</code></pre>

<p>{% endcodeblock %}</p>

<p>第一行的getValue谓词把操作数分成了FirstOperand和OtherOperands，实际上表明了[add]这样的输入是不合法的，它后面必须至少有一个操作数。下面让问题再复杂一些，Operands中不仅包含数字，还递归地包含一个加法表达式，</p>

<p>{% codeblock lang:scheme %}
[add, 1, [add, 2, 3], 4]
{% endcodeblock %}
观察前面的代码，我们发现这时会引发问题的地方是下面这行代码，</p>

<p>{% codeblock lang:scheme %}
NewResult is ResultSoFar + H,
{% endcodeblock %}</p>

<p>它从操作数列表中取出第一个元素（H），然后把它追加到ResultSoFar。但是这里并没有区分H的类型——数字还是列表，如果H是一个列表，那么我们还要先对它进行求值，</p>

<p>{% codeblock lang:scheme %}
getValue(H, Value),
NewResult is ResultSoFar + Value,
{% endcodeblock %}</p>

<p>当然，如果H是一个数字，那么Value就是它自身，下面的谓词表述了这个含义，</p>

<p>{% codeblock lang:scheme %}
getValue(Number, Number) :- number(Number).
{% endcodeblock %}
这样，我们就扩展了getValue谓词的抽象级别，而且也反映了scheme语言的“函数性”。在解释执行scheme的过程中，要做的事情就是不断地求值，表达式有值，一个数字也有值（就是它自身），后面会看到遇到变量时也要对它求值。</p>

<p>下面要让运行时可以执行除了加法以外其他的四则运算了。在前面的程序中，“add”其实只是个花瓶，对后面的计算过程没有丝毫影响，事实上“NewResult is ResultSoFar + H”会无条件地执行加法。因此我们要把操作符add（以及minus，multi，div）传递给后面的谓词，当然，传递前我们判断它们是否是合法的操作符：</p>

<p>{% codeblock lang:scheme %}
operator(add).
operator(minus).
operator(multi).
operator(div).
{% endcodeblock %}</p>

<p>上面四个谓词描述了目前我们支持的四种操作符。下面所有元数为3（参数个数为3）的getValue谓词都要增加一个参数，即操作符。最后，还需要一组谓词来根据不同的操作符完成最终的计算，</p>

<p>{% codeblock lang:scheme %}
getValue([Operator, FirstOperand|OtherOperands], Result) :-</p>

<pre><code>operator(Operator),
getValue(Operator, FirstOperand, OtherOperands, Result).
</code></pre>

<p>getValue(Operator, ResultSoFar, [H|T], Result) :-</p>

<pre><code>getValue(H, Value),
calculate(Operator, ResultSoFar, Value, NewResult),
getValue(Operator, NewResult, T, Result).
</code></pre>

<p>calculate(add, Oper1, Oper2, Result) :- Result is Oper1 + Oper2.
calculate(minus, Oper1, Oper2, Result) :- Result is Oper1 - Oper2.
calculate(multi, Oper1, Oper2, Result) :- Result is Oper1 * Oper2.
calculate(div, Oper1, Oper2, Result) :- Result is Oper1 / Oper2.
{% endcodeblock %}</p>

<p>如上代码所示，真正的运算是在calculate谓词中完成的，它会根据不同的操作符进行不同的计算。现在，我们还有一种语句需要处理，(define a 1)，目前的谓词不能识别第一个元素是define的列表。所以我们要一个谓词来“忽略”这样的语句：</p>

<p>{% codeblock lang:scheme %}
getValue([<em>|</em>], _).
{% endcodeblock %}</p>

<p>单独一个运算语句已经能够处理了，我们可以简单地把它扩展到多个语句的情况。一个run谓词可以完成这件事：</p>

<p>{% codeblock lang:scheme %}
run([]).
run([FirstStmt|OtherStmts]) :-</p>

<pre><code>getValue(FirstStmt, Result),
writeln(Result),
run(OtherStmts).
</code></pre>

<p>{% endcodeblock %}</p>

<p>现在，这个运行时环境可以解释执行下面“复杂”的代码了：</p>

<p>{% codeblock lang:scheme %}
(define a 1)
(<em> 3 5)
(+ 1 (- 5 2) (</em> 3 (/ 20 5)))
{% endcodeblock %}</p>

<p>计算的结果是15和16，而第一行define则被忽略掉了。</p>

<p>到目前为止，我们完成了源代码读取、词法分析、文法分析、运行时解析的步骤，这个简单的解析器能够计算不含变量的四则运算。但是作为一个体面的运行时，我们要给它增加定义变量的能力。关于变量的作用域，在本文的开始已经描述过。我们知道，“符号表”是支持变量的核心要素，本文的最后一部分我将讲述如何构建符号表。</p>

<p>符号表本质上就是个字典，里面保存了变量名和变量值的映射。Prolog并没有直接提供字典，但是我们可以用一个二维数组来模拟：</p>

<p>{% codeblock lang:scheme %}
[[ident(a), 1], [ident(b), 2]]
{% endcodeblock %}</p>

<p>ident(a)和ident(b)表示变量a和b，这种表示是为了和a、b的原子形式区分。接下来，创建符号表的谓词并不复杂：</p>

<p>{% codeblock lang:scheme %}
createSymbolTables(Stmts, ST) :-</p>

<pre><code>createSymbolTable(Stmts, [], ST).
</code></pre>

<p>createSymbolTable([], ST, ST).</p>

<p>createSymbolTable([[define, ident(Id), Number]|OtherStmts], STSoFar, ST) :-</p>

<pre><code>number(Number),
createSymbolTable(OtherStmts, [[Id,Number]|STSoFar], ST).
</code></pre>

<p>createSymbolTable([_|T], ST) :- createSymbolTables(T,ST).
{% endcodeblock %}</p>

<p>其中最后一个谓词是为了在创建符号表的过程中，只关心define语句，忽略掉其他运算语句。</p>

<p>关于符号表，创建它只是故事的一半，通过符号表查询某个变量的值是另一件重要的事。</p>

<p>{% codeblock lang:scheme %}
search(<em>, [], </em>) :- false.
search(Id, [[Id,Value]|<em>], Value).
search(Id, [</em>|T], Value) :-</p>

<pre><code>search(Id, T, Value).
</code></pre>

<p>{% endcodeblock %}</p>

<p>当遍历到最后一个符号表的时候，如果仍然找不到某个变量的值，这将被认为是一个程序错误，所以，上面第一个search谓词是以false结束的。另外，如果search在第一个谓词时失败的话，它已经没有回朔的余地了，这样将继而导致整个Prolog运行时失败。这个行为是合理的，任何时候，当遇到一个没有定义的变量时程序都应该停机。</p>

<p>创建完成了符号表，我们现在可以扩展运行时来支持定义变量了。运行时现在应该遍历两次AST，第一次创建符号表ST，第二次解释求值：</p>

<p>{% codeblock lang:scheme %}
scheme(Stmts) :-</p>

<pre><code>createSymbolTables(Stmts, ST),
run(Stmts, ST).
</code></pre>

<p>{% endcodeblock %}</p>

<p>我们看到run谓词已经多了一个ST参数，ST也会进而传递给下面的getValue谓词。在前面的代码中，getValue可以对四则运算和数字求值了，现在我们要扩展它，让它可以对变量求值，当然，这是指从符号表中找出这个变量对应的值：</p>

<p>{% codeblock lang:scheme %}
getValue(ST, ident(Id), Value) :- search(Id, ST, Value).
{% endcodeblock %}</p>

<p>正如刚刚提到的，getValue多了一个参数ST，其他的getValue也是一样，尽管它们并不需要它。</p>

<p>好了，深呼吸一下吧，再整理整理手头的代码。如果你跟上了这篇文章的步伐，会看到一个Scheme子集的运行时环境。如果没跟上也没关系，下面的<a href="https://github.com/isaachan/scheme-runtime">链接</a>提供了源代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (3)：文法分析]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">上一篇文章</a>中，我们完成了词法分析，从源代码文件中获得了词法单元的序列。接下来，这些词法单元会被送到文法分析器中做进一步处理。我们知道，形式文法是由一组文法生成式组成的。一个生成式可能是这样子的，</p>

<p>{% codeblock lang:antlr %}
IfStat -> 'if' '(' Expr ')' StateBlock
{% endcodeblock %}</p>

<p>这是常见的描述if语句的生成式，它表达了这样的含义：如果匹配了‘if’，并且匹配了'('，并且匹配了Expr，并且匹配了')'，并且遇到了StateBlock，那么就匹配了一个完整的IfStat。这里我故意使用了“如果”、“并且”、“那么”，目的是想说明文法生成式和Prolog语句是有着惊人的相似的。每一个生成式实际上就是一个命题。因此，相对于命令式语言，用Prolog进行文法解析是一件比较简单的工作。下面，我们开始用Prolog实现简单Scheme的文法分析部分。</p>

<!-- more -->


<h2>文法分析</h2>

<p>我们先来看一下本文中作为范例的Scheme的文法，它自身非常简单，这也是选择它做范例的原因：</p>

<p>{% codeblock lang:antlr %}
prog -> statement<em>
statement -> '(' item</em> ')'
item -> identifier |</p>

<pre><code>     digit |
     '+' |
     '-' |
     '*' |
     '/' |
     statement
</code></pre>

<p>{% endcodeblock %}</p>

<p>很简单，是不是？好，下面我们从最高层的谓词开始，由抽象到具体，逐步构造scheme的解析器。第一个谓词是parser，它的输入参数是一串词法单元，输出参数是statement的列表。如果输入的词法单元为空，那么输出的statement也为空；否则，parser会调用其他谓词来收集所有的statement：</p>

<p>{% codeblock lang:scheme %}
parser([], []).
parser(Tokens, Statements) :- matchStatements ...
{% endcodeblock %}</p>

<p>matchStatements谓词真正完成了收集statment的工作。下面是matchStatements的代码：</p>

<p>{% codeblock lang:scheme %}
matchStatements([], _, StatementsSoFar, Statements) :-</p>

<pre><code>reverse(StatementsSoFar, Statements).
</code></pre>

<p>matchStatements(In, Out, StatementsSoFar, Statements) :-</p>

<pre><code>statement(In, TempOut, OneStatement),
matchStatements(TempOut, Out, [OneStatement|StatementsSoFar], Statements).
</code></pre>

<p>{% endcodeblock %}</p>

<p>它和前面getTokens谓词几乎是一样的。事实上，无论是识别Token，还是识别statement，它们的过程并无本质的区别。</p>

<p>接下来看看statement谓词如何实现。从前面的文法可知，要匹配statement，需要先匹配一个左括号，然后是若干个item，最后是一个右括号。把这段话“翻译”为Prolog代码是很容易的：</p>

<p>{% codeblock lang:scheme %}
statement(In, Out, Items) :-</p>

<pre><code>match(In, lp, AfterMatchedLp),
matchItems(AfterMatchedLp, AfterMatchedItems, Items),
match(AfterMatchedItems, rp, Out)
</code></pre>

<p>{% endcodeblock %}</p>

<p>这里我们遇到两个新的谓词，match和matchItems。首先是match，它用于推断一个词法单元序列的第一个元素是否是某个特定的词法单元，而它的输出参数是去掉一个元素后剩余的词法单元。由于match非常简单，此处暂时不给出其代码了。</p>

<p>最后是matchItems谓词。它的任务就是收集statement中的每一项（item），比如对于(+ 1 2)，matchItems就会发现三个项，'+'、'1'、'2'；另外，对于(+ (- 3 2) 1)，matchItems也会发现三个项，'+'、'(- 3 2)'、'1'，不过第二项比较特殊，它又是一个statement，由另外三项组成。最后，何时结束matchItems呢？那就是当matchItems遇到'('的时候。基于上述讨论的三种情况，我们需要分别写出三个matchItems谓词，按照由特殊到一般的原则，我们首先处理matchItems遇到'('和')'的情况，最后是一般的情况。</p>

<p>{% codeblock lang:scheme %}
matchItems(In, Out, ItemsSoFar, Items) :-</p>

<pre><code>statement(In, TempOut, ItemValue), 
matchItems(TempOut, Out, [ItemValue|ItemsSoFar], Items). 
</code></pre>

<p>matchItems([rp|In], [rp|In], ItemsSoFar, Items) :- reverse(ItemsSoFar, Items).</p>

<p>matchItems(In, Out, ItemsSoFar, Items) :-</p>

<pre><code>match(In, Item, TempOut), 
matchItems(TempOut, Out, [Item|ItemsSoFar], Items)
</code></pre>

<p>{% endcodeblock %}</p>

<p>相信现在你应该能够很容易地看懂这段代码了吧。</p>

<p>最后我们再来看看解析器的输出。前面file和getTokens的谓词都十分明确，前者是文件的字节流，后者是词法单元的序列。而parser的输出通常有两种，一种是基于语法制导，在解析的过程里完成对语言的解释和执行，很多脚本语言和简单的语言都是这样做的；另一种则是生成抽象语法树(AST)或者其他中间形式，以供后续的阶段消费。多数复杂的语言都会在解析阶段输出AST。AST相对于源代码要精简很多，便于语言运行时进行多趟处理，比如优化、类型推演等，是难以在一趟中完成的。在本文的例子中，由于我们要支持define定义的变量，而且变量的定义是可以后于其使用的，因此运行时需要在编译后和运行前增加一个步骤——创建符号表。综上，本文选择了AST作为parser谓词的最终输出。</p>

<p>然而，Prolog并不直接支持tree数据结构，只有支持列表，如何用列表实现tree是二维结构呢？这也不难。计算机的存储结构自身是一维线性的，本质上就是一个列表，因此任何tree结构最终都要转化成列表，比如下面的tree</p>

<p><img src="/images/scheme-parser-using-prolog/computer.gif" alt="计算机结构图" />
计算机结构图</p>

<p>那么我们可以用下面的列表表示这棵树[computer, [cpu, Intel, 2.83G], [memery, 8G, DDR], [monitor, 15', LCD], [keyborad, “USA Standard”]]，这样二维的数据结构就可以由一维的列表表示了。对于Prolog来说，这件事格外容易。假如有下面的代码：</p>

<p>{% codeblock lang:scheme %}
(define a 1)
(+ (- 3 2) 1)
{% endcodeblock %}</p>

<p>那么parser谓词的输出将是：[[define, a, 1], [add, [minus, 3, 2], 1]]。最外层的列表包含两个元素，[define, a, 1]和[add, [minus, 3, 2], 1]，它们分别都是列表，并且第二个元素中又包含了其他的列表。</p>

<p>现在，可以把我们已经有的谓词组合到一起了，</p>

<p>{% codeblock lang:scheme %}
:- file(“example.ss”, FileContent),
   getTokens(FileContent, Tokens),
   parser(Tokens, Statements).
{% endcodeblock %}</p>

<p>下来是本文的<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/">最后一部份</a>，scheme的运行时，启程吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (2)：词法分析]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2</id>
    <content type="html"><![CDATA[<p>在上一篇“<a href="/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">读取源文件</a>”的文章中，我们实现了readFile谓词，利用它可以读取源文件的内容，并把字节流保存在一个整数的列表中。接下来我们将消费这些数据，通过它们创建词法单元。因此，本节将讲述如何构造一个词法分析器来完成这件事。</p>

<h2>词法分析</h2>

<p>就像在第一节已经指出的，本文处理的只是Scheme的子集，它的词法规则如下：</p>

<ul>
<li>+, -, *, /, (, ),Whitespace</li>
<li>'define'</li>
<li>identifier number</li>
</ul>


<!-- more -->


<p>第一行列出的词法单元只包含一个字符，第二行的‘define’是一个关键字，虽然它不是一个字符组成的，但是仍然是固定长度的。第三行的identifier和number是标识符和数字，它们几乎出现在所有语言中，并且它们的长度不是固定的。</p>

<p>很明显，第一行中的词法单元是最容易识别的，下面这些谓词描述如何识别它们：</p>

<p>{% codeblock lang:scheme %}
getToken([40|Rest], Rest, lp). %% (
getToken([41|Rest], Rest, rp). %% )
getToken([42|Rest], Rest, mult). %% *
getToken([43|Rest], Rest, plus). %% +
getToken([45|Rest], Rest, minus). %% -
getToken([47|Rest], Rest, div). %% /
getToken([32|Rest], Rest, ws). %% WhiteSpace
getToken([9|Rest], Rest, ws). %% WhiteSpace
getToken([10|Rest], Rest, ws). %% WhiteSpace
{% endcodeblock %}</p>

<p>这段代码实现了getToken谓词，这个谓词的第一个参数是进行词法单元匹配以前的字节流，第二个参数是匹配过词法单元后剩余的字符流，第三个参数表示此次getToken匹配到的词法单元。代码中出现的整数，40，41，42...是字符的ASCII码，后面的注释解释了它代表的字符。上述代码中的[40|Rest]的词法单元是一个列表，它的第一个元素是40，其他元素是Rest。这很类似于scheme中的car和cdr操作。[]则表示一个空的列表。Prolog的这种文法极大的方便了列表的处理。如果你熟悉Erlang，会发现它和Prolog处理列表的文法和语义是一样的（事实上这两种语言也确实深有渊源！）。</p>

<p>接下来，我们看看如何识别define关键字。由于这个词法单元的长度是固定的，因此识别它也并不复杂：</p>

<p>{% codeblock lang:scheme %}
getToken([100,101,102,105,110,101|Rest], Rest, define). %% define
{% endcodeblock %}</p>

<p>这里，我们用到了列表的另一种文法，[100,101,102,105,110,101|Rest]表示列表的前六个元素一次是 100,101,102,105,110,101。因此这个谓词可以匹配define。</p>

<p>现在我们已经可以匹配除标识符和数字以外的其他词法单元了，那么如何把所有匹配到的词法单元收集到一起呢？嗯，我们需要一个getTokens谓词来收集词法单元，如果输入的字节列表为空，那么收集工作宣告结束；否则，它应该能重复地调用getToken，前一个getToken的输出是后一个getToken的输入。哦，对了，Prolog没有for循环，用递归才能实现重复执行一段代码的工作。OK，getTokens谓词的代码应该是这样子了：</p>

<p>{% codeblock lang:scheme %}
getTokens([], TokensSoFar, Tokens) :- reverse(TokensSoFar, Tokens).
getTokens(Input, TokensSoFar, Tokens) :-</p>

<pre><code>getToken(Input, Rest, OneToken), 
getTokens(Rest, [OneToken|TokensSoFar], Tokens).
</code></pre>

<p>{% endcodeblock %}</p>

<p>TokensSoFar用来收集计算过程中匹配的词法单元，但是它收集的顺序和词法单元真正的顺序是相反的，因为geTokens总是把后遇到的词法单元放到TokensSoFar的头部，这是受到Prolog列表处理的限制。当输入字节流为空时，把TokensSoFar中的词法单元反向排序，就得到了我们想要的答案。</p>

<p>在进行词法分析的过程中，我们通常要丢弃一些无用的词法单元，比如注释、空白符等等。我们的Scheme子集不支持注释，所以这里我们只要丢弃掉空白符即可。当getTokens遇到一个ws词法单元的时候，不要把它加到TokensSoFar的头部，而是直接忽略掉：</p>

<p>{% codeblock lang:scheme %}
getTokens([], TokensSoFar, Tokens) :- reverse(TokensSoFar, Tokens).
getTokens(Input, TokensSoFar, Tokens) :-</p>

<pre><code>getToken(Input, Rest, ws), 
getTokens(Rest, TokensSoFar, Tokens). 
</code></pre>

<p>getTokens(Input, TokensSoFar, Tokens) :-</p>

<pre><code>getToken(Input, Rest, OneToken), 
getTokens(Rest, [OneToken|TokensSoFar], Tokens).
</code></pre>

<p>{% endcodeblock %}</p>

<p>这个getTokens谓词的位置很重要，它必须位于原来两个谓词之间。Prolog在模式匹配相同签名的谓词的时候，会按照它们声明的先后顺序进行尝试，因此必须把描述特殊情况的谓词排在前面，一般情况的谓词排在后面。</p>

<p>词法分析完成了吗？不不，我们还没有实现匹配标识符和数字的谓词！标识符和数字稍微复杂一些，它们的长度不是固定的，因此在匹配它们的getToken谓词中，还需要多一个参数，用来临时保存计算过程中已匹配的字节。在实现getToken之前，先看一下描述数字的自动机，</p>

<p><img src="/images/scheme-parser-using-prolog/number-fsm.gif" alt="状态机" /></p>

<p>标识符的自动机和它是类似的。我们可以这样描述该自动机的行为：如果输入的第一个字节是数字，则进入number状态，并记录下这个数字；在number状态下，如果输入的第一个字节是数字，则继续追加该数字； 在number状态下，如果输入的第一个字节是字符，则是非法输入；在number状态下，如果输入的第一个字节是+ - * / ( ) Ws中的任何一个，则结束number状态，并完成一个number词法单元的识别。</p>

<p>{% codeblock lang:scheme %}
getToken([D|T], Rest, Nubmer) :-</p>

<pre><code>digit(D),
getNumberToken(T, Rest, [D], Number).
</code></pre>

<p>getNumberToken([D|T], Rest, DigitsSoFar, Number) :-</p>

<pre><code>digit(D),
getToken(T, Rest, [D|DigitsSoFar], Number).
</code></pre>

<p>getNumberToken([H|T], [H|T], DigitsSoFar, Number) :-</p>

<pre><code>single(H),
reverse(DigitsSoFar, Number).
</code></pre>

<p>digit(D) :- 47 &lt; D, D &lt; 58.
single(T) :- T=39; T=9; T=10; T=40; T=41; T=42; T=43; T=45; T=47.
{% endcodeblock %}</p>

<p>第一个getToken谓词描述了从非number状态到number状态的转换。进入Number状态后，开始调用getNumberToken谓词。getNumberToken谓词有两个，分别处理digit和那些只包含一个字符的词法单元。出于简单的考虑，这段程序没有显式地处理遇到字母字符的情况（比如打印一段错误信息），那么，如果在number状态下遇到字母字符时，由于没有相应的谓词可以去匹配，程序同样无法成功运行。最后，在程序的第一行，Rest的值也不是根据它前面的参数确定的了。因为只有读取完所有连续的数字后，才知道Rest的起点在哪里。在第9行，Rest最终被确定下来。这里Rest之所以是[H|T]而不是T，因为当读到一个符合single谓词的字节时，意味着number读取结束了，而刚刚读到的这个字节还要留给下一个谓词去处理，不能在这里吞噬掉。</p>

<p>关于匹配标识符的谓词，和匹配number的谓词几乎一样，在这里就不多赘述了。本文后面会提供所有的源代码。</p>

<p>目前getTokens谓词需要三个参数，FileContent, TokensSoFar和Tokens。其中TokensSoFar的初始值必然是一个空的列表。因此，我们可以再创建一个谓词来“封装”这里参数，从而留给调用者一个更友好的API。</p>

<p>{% codeblock lang:scheme %}
   getTokens(FileContent, Tokens)</p>

<pre><code>   :- getTokens(FileContent, [], Tokens).
</code></pre>

<p>{% endcodeblock %}</p>

<p>现在，我们有file和getTokens两个谓词了，把它们写在一起已经可以分析指定文件的词法了。</p>

<p>{% codeblock lang:scheme %}
:- file(“example.ss”, FileContent),
   getTokens(FileContent, Tokens).
{% endcodeblock %}</p>

<p>接下了，将是更有挑战的工作——<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">文法分析</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (1)：读取源文件]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/"/>
    <updated>2014-10-02T22:53:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1</id>
    <content type="html"><![CDATA[<p>在接下来的一系列文章里，我将详细讲述如何利用Prolog，从零开始构造一个Scheme子集的<a href="https://github.com/isaachan/scheme-runtime">运行时环境</a>。这个运行时环境可以解释执行如下四则运算的Scheme代码：</p>

<p>{% codeblock lang:scheme %}
(+ 1 2)
(+ (- 5 3) (* 2 3))
{% endcodeblock %}</p>

<p>另外，它还可以通过“define”定义变量，
{% codeblock lang:scheme %}
(define a 1)
(define b 2)
(+ a b)
...
{% endcodeblock %}</p>

<p>选择Scheme的原因在于它足够简单而且有趣。另外，通过实现这个简单的运行时环境，我们也可以领略Prolog的独特之处。Prolog作为应用最广泛的逻辑式程序设计语言，在描述文法生成式时具有很多语言无可比拟的优势；另外作为声明式语言，Prolog不必描述运算的细节（甚至语句执行的顺序），因此程序的可读性比命令式语言要好很多。</p>

<!-- more -->


<p>正如前面的代码所示，我们实现的解析器只能执行简单的四则运算，但是它却涉及到读取源文件、词法分析、语法分析和构造符号表等技术，这些是所有高级编译器都具有的功能。因此本文分为四个部分，分别讲述下面四个问题：</p>

<ul>
<li>读取源文件</li>
<li>词法分析</li>
<li>语法分析</li>
<li>运行时环境</li>
</ul>


<h2>读取源文件</h2>

<p>读取源代码文件是后续分析、解释执行的第一步。这个示例程序并没有提供交互式运行的机制，因此从文本文件中读取代码并运行是唯一的启动程序的方式。</p>

<p>谓词推演是Prolog解决问题的手段，无论待解决的问题看上去和谓词推演多么的不相关。不过，谓词推演是足够强大的，足以解决“读取文件内容”的问题。我们设计一个谓词，用来从最高的层次上读取文件的内容：</p>

<p>{% codeblock lang:scheme %}
file(FilePath, FileContent).
{% endcodeblock %}</p>

<p>这个谓词的含义是：当FilePath是一个文件路径，并且FileContent是该文件的内容时，这个谓词为真，否则为假。当然，如果我们只告诉这个谓词FilePath的信息，Prolog运行时会找到FileContent的值，使这个谓词为真。正是由于这一点，file谓词可以为我们读取文件的内容了。</p>

<p>为了实现这个谓词，我们还需要完成一些工作，比如如何获取Prolog运行时内部的文件句柄？如何从文件句柄中依次读取数据？如何知道是否读到了文件的尾部？</p>

<p>调用其他Prolog运行时内置的与文件相关的谓词，它们要能够获取文件句柄，并从句柄中依次读取文件字节。简单地查找Prolog的文档，不难发现下面两个内置的谓词：</p>

<p>{% codeblock lang:scheme %}
open(+FilePath, +OpenMode, -Stream, +Options).
get0(+Stream, -Char).
{% endcodeblock %}</p>

<p>open谓词的第一个参数是文件路径，第二个是打开文件的模式，可以是read/write/append/update之中的一个，第三个是文件句柄，第四个是额外的选项，比如字符集、缓存大小等。get0的第一个参数是文件句柄，它通常是open的输出参数Stream，第二个参数是读出的字符。get0会维护访问文件的指针，当每次调用get0时，指针会自动向后移动，当到达文件尾部的时候，Char等于-1。有了这两个谓词，我们可以进一步实现file谓词，</p>

<p>{% codeblock lang:scheme %}
file(FilePath, FileContent) :-</p>

<pre><code>open(FilePath, read, Stream, [eof_action(eof_code)]), 
readFile(Steam, FileContent).
</code></pre>

<p>{% endcodeblock %}</p>

<p>这里增加了一个readFile谓词，它会把Stream中的字节流保存到FileContent中。谓词readFile的实现可以描述如下：如果从Stream中读取的字节是-1（即到文件尾），那么读取完毕；如果从Stream中读取的字节不是-1，那么把该字节追加到已经读取的序列中，然后递归地调用readFile。下面的代码反映了这一描述：</p>

<p>{% codeblock lang:scheme %}
readFile(Stream, ContentSoFar, FileContent) :-</p>

<pre><code>get0(Stream, -1),
reverse(ContentSoFar, FileContent).
</code></pre>

<p>readFile(ContentSoFar, FileContent) :-</p>

<pre><code>get0(Stream, Char),
readFile(Stream, [Char|ContentSoFar], FileContent).
</code></pre>

<p>{% endcodeblock %}</p>

<p>在这段代码中，我们首先为readFile增加了一个参数：ContentSoFar，用来保存在计算过程中收集的不完整的文件内容，当将文件全部读取结束后，再把ContentSoFar的内容反序排列后与FileContent进行合一。我们注意到在第二个readFile中，[Char|ContentSoFar]会导致先读取到字节后放到ContentSoFar序列的后端。这就是说，如果读取的文件内容是123abc，那么ContentSoFar最终的值将是['c', 'b', 'a', '3', '2', '1']。因此在第一个readFile的最后，需要把ContentSoFar反序排列后再与FileContent进行合一。</p>

<p>另外，get0的文档提到了，它读取的字节是一个int数值，代表了这个字节的ASCII码。出于测试的目的，我们不想看到读出的内容是一串数字，那么可以用atom_chars谓词将数字串转化为字符串，并使用write谓词将它输出到控制台上：</p>

<p>{% codeblock lang:scheme %}
display(file) :-</p>

<pre><code>readFile(file, FileContent), 
atom_char(FileContent, FileContentChar),
write(FileContentChar).
</code></pre>

<p>{% endcodeblock %}</p>

<p>现在回过头来看看我们刚刚完成的readFile谓词，它的运行起来效果如何呢？我在尝试读取的文件如下文件：</p>

<p>{% codeblock lang:scheme %}
(define a 11)
(+ 1 a)
{% endcodeblock %}</p>

<p>发现程序总是意外出错中止。检查了错误信息后，我发现它读取的内容是：</p>

<p>{% codeblock lang:scheme %}
dfn 1
+1a
{% endcodeblock %}</p>

<p>程序每读取一个字节会跳过一个字节。经过分析，我找到了错误的原因。当调用readFile谓词的时候，Prolog首先尝试第一个readFile的定义，即调用get0，并期望读到文件尾（-1），这当然是不成立的，于是程序回朔，继续尝试第二个readFile的定义。但是上一次失败已经改变了get0内部维护的文件指针，而且文件指针也不会随着回朔而改变，这就产生了我们前面看到的情况。每经由递归读取一个字节时，都要尝试第一个readFile的定义，而直到真的读取到了文件尾之前，它总是会失败而引起回朔，从而丢失一个字节。为了修正这个问题，需要如下修改我们的代码：</p>

<p>{% codeblock lang:scheme %}
readFile(Stream, Content) :-</p>

<pre><code>get0(Stream, A), 
readFile(Stream, A, Content). 
</code></pre>

<p>readFile(_, -1, []).
readFile(Stream, A, [A|Content]) :- readFile(Stream, Content).
{% endcodeblock %}</p>

<p>这样，判断读取的字符是否为-1的任务下推给了readFile谓词，确保get0不会参与到回朔过程。另外，由于使用了不同的递归方式，新的实现可以直接读取正确顺序的文件字节流，不需要再次反序排列。</p>

<p>完成了读取源文件的工作，接下来我们就可以进行<a href="/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>了。</p>
]]></content>
  </entry>
  
</feed>
