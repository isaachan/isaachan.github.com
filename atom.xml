<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[To iterate is human, to recurse divine.]]></title>
  <link href="http://isaachan.github.com/atom.xml" rel="self"/>
  <link href="http://isaachan.github.com/"/>
  <updated>2014-10-04T11:48:41+08:00</updated>
  <id>http://isaachan.github.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (4)：运行时环境]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4</id>
    <content type="html"><![CDATA[<p>现在，我们已经用Prolog实现了范例Scheme语言的<a href="http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">源代码读取</a>、<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>和<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">语法分析</a>的部分，并且获得了AST。最后，我们要实现一个Scheme的运行时来消费AST，生成最终的计算结果。</p>

<p>当解析器生成了抽象语法树(AST)后，运行时环境可以对它进行处理，计算语法树表达的数值。如果代码只是如下简单的四则运算，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>那么对AST遍历一次就足够了，甚至在解析的过程中就可以获得结果了，根本不需要生成AST。但是，我们希望这个运行时能够支持通过define定义变量，甚至变量的作用域是全局的，而不仅仅是从它声明的地方开始，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这段程序的输出应该是3，而不是“b没有声明”的错误信息，因为define定义的变量的作用域贯穿所有的代码。对于这一要求，我们需要遍历两次AST，第一次构建符号表，第二次完成运算。在实际的开发中，我们会先完成第二步的功能，即先不考虑代码中存在变量的情况，然后在逐步地加入对变量的支持。</p>

<p>让我们呢先看看最简单的情形，求这个表达式的值</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>按照前面的分析，解析器会生成下面的AST，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">[</span><span class="nv">plus,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>连续累加plus后面的元素，这需要一个简单的递归就够了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">([</span><span class="nv">add,</span> <span class="nv">FirstOperand|OtherOperands</span><span class="p">]</span><span class="o">,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">FirstOperand,</span> <span class="nv">OtherOperands,</span> <span class="nv">Result</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">ResultSoFar,</span> <span class="p">[]</span><span class="o">,</span> <span class="nv">ResultSoFar</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">ResultSoFar,</span> <span class="p">[</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">NewResult</span> <span class="nv">is</span> <span class="nv">ResultSoFar</span> <span class="nv">+</span> <span class="nv">H,</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">NewResult,</span> <span class="nv">T,</span> <span class="nv">Result</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一行的getValue谓词把操作数分成了FirstOperand和OtherOperands，实际上表明了[add]这样的输入是不合法的，它后面必须至少有一个操作数。下面让问题再复杂一些，Operands中不仅包含数字，还递归地包含一个加法表达式，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">[</span><span class="nv">add,</span> <span class="mi">1</span><span class="o">,</span> <span class="p">[</span><span class="nv">add,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">,</span> <span class="mi">4</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>观察前面的代码，我们发现这时会引发问题的地方是下面这行代码，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">NewResult</span> <span class="nv">is</span> <span class="nv">ResultSoFar</span> <span class="nv">+</span> <span class="nv">H,</span>
</span></code></pre></td></tr></table></div></figure>


<p>它从操作数列表中取出第一个元素（H），然后把它追加到ResultSoFar。但是这里并没有区分H的类型——数字还是列表，如果H是一个列表，那么我们还要先对它进行求值，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">H,</span> <span class="nv">Value</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'><span class="nv">NewResult</span> <span class="nv">is</span> <span class="nv">ResultSoFar</span> <span class="nv">+</span> <span class="nv">Value,</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，如果H是一个数字，那么Value就是它自身，下面的谓词表述了这个含义，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">Number,</span> <span class="nv">Number</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">number</span><span class="p">(</span><span class="nf">Number</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，我们就扩展了getValue谓词的抽象级别，而且也反映了scheme语言的“函数性”。在解释执行scheme的过程中，要做的事情就是不断地求值，表达式有值，一个数字也有值（就是它自身），后面会看到遇到变量时也要对它求值。</p>

<p>下面要让运行时可以执行除了加法以外其他的四则运算了。在前面的程序中，“add”其实只是个花瓶，对后面的计算过程没有丝毫影响，事实上“NewResult is ResultSoFar + H”会无条件地执行加法。因此我们要把操作符add（以及minus，multi，div）传递给后面的谓词，当然，传递前我们判断它们是否是合法的操作符：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">operator</span><span class="p">(</span><span class="nf">add</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">operator</span><span class="p">(</span><span class="nf">minus</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">operator</span><span class="p">(</span><span class="nf">multi</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">operator</span><span class="p">(</span><span class="nf">div</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面四个谓词描述了目前我们支持的四种操作符。下面所有元数为3（参数个数为3）的getValue谓词都要增加一个参数，即操作符。最后，还需要一组谓词来根据不同的操作符完成最终的计算，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">([</span><span class="nv">Operator,</span> <span class="nv">FirstOperand|OtherOperands</span><span class="p">]</span><span class="o">,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">operator</span><span class="p">(</span><span class="nf">Operator</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">Operator,</span> <span class="nv">FirstOperand,</span> <span class="nv">OtherOperands,</span> <span class="nv">Result</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">Operator,</span> <span class="nv">ResultSoFar,</span> <span class="p">[</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">H,</span> <span class="nv">Value</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">calculate</span><span class="p">(</span><span class="nf">Operator,</span> <span class="nv">ResultSoFar,</span> <span class="nv">Value,</span> <span class="nv">NewResult</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">Operator,</span> <span class="nv">NewResult,</span> <span class="nv">T,</span> <span class="nv">Result</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">calculate</span><span class="p">(</span><span class="nf">add,</span> <span class="nv">Oper1,</span> <span class="nv">Oper2,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">Result</span> <span class="nv">is</span> <span class="nv">Oper1</span> <span class="nv">+</span> <span class="nv">Oper2</span><span class="o">.</span>
</span><span class='line'><span class="nv">calculate</span><span class="p">(</span><span class="nf">minus,</span> <span class="nv">Oper1,</span> <span class="nv">Oper2,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">Result</span> <span class="nv">is</span> <span class="nv">Oper1</span> <span class="nv">-</span> <span class="nv">Oper2</span><span class="o">.</span>
</span><span class='line'><span class="nv">calculate</span><span class="p">(</span><span class="nf">multi,</span> <span class="nv">Oper1,</span> <span class="nv">Oper2,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">Result</span> <span class="nv">is</span> <span class="nv">Oper1</span> <span class="nv">*</span> <span class="nv">Oper2</span><span class="o">.</span>
</span><span class='line'><span class="nv">calculate</span><span class="p">(</span><span class="nf">div,</span> <span class="nv">Oper1,</span> <span class="nv">Oper2,</span> <span class="nv">Result</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">Result</span> <span class="nv">is</span> <span class="nv">Oper1</span> <span class="nv">/</span> <span class="nv">Oper2</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上代码所示，真正的运算是在calculate谓词中完成的，它会根据不同的操作符进行不同的计算。现在，我们还有一种语句需要处理，(define a 1)，目前的谓词不能识别第一个元素是define的列表。所以我们要一个谓词来“忽略”这样的语句：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">([</span><span class="nv">_|_</span><span class="p">]</span><span class="o">,</span> <span class="nv">_</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>单独一个运算语句已经能够处理了，我们可以简单地把它扩展到多个语句的情况。一个run谓词可以完成这件事：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">run</span><span class="p">([])</span><span class="o">.</span>
</span><span class='line'><span class="nv">run</span><span class="p">([</span><span class="nv">FirstStmt|OtherStmts</span><span class="p">])</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getValue</span><span class="p">(</span><span class="nf">FirstStmt,</span> <span class="nv">Result</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">writeln</span><span class="p">(</span><span class="nf">Result</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">run</span><span class="p">(</span><span class="nf">OtherStmts</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，这个运行时环境可以解释执行下面“复杂”的代码了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">20</span> <span class="mi">5</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>计算的结果是15和16，而第一行define则被忽略掉了。</p>

<p>到目前为止，我们完成了源代码读取、词法分析、文法分析、运行时解析的步骤，这个简单的解析器能够计算不含变量的四则运算。但是作为一个体面的运行时，我们要给它增加定义变量的能力。关于变量的作用域，在本文的开始已经描述过。我们知道，“符号表”是支持变量的核心要素，本文的最后一部分我将讲述如何构建符号表。</p>

<p>符号表本质上就是个字典，里面保存了变量名和变量值的映射。Prolog并没有直接提供字典，但是我们可以用一个二维数组来模拟：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">[[</span><span class="nv">ident</span><span class="p">(</span><span class="nf">a</span><span class="p">)</span><span class="o">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="nv">ident</span><span class="p">(</span><span class="nf">b</span><span class="p">)</span><span class="o">,</span> <span class="mi">2</span><span class="p">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>ident(a)和ident(b)表示变量a和b，这种表示是为了和a、b的原子形式区分。接下来，创建符号表的谓词并不复杂：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">createSymbolTables</span><span class="p">(</span><span class="nf">Stmts,</span> <span class="nv">ST</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">createSymbolTable</span><span class="p">(</span><span class="nf">Stmts,</span> <span class="p">[]</span><span class="o">,</span> <span class="nv">ST</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">createSymbolTable</span><span class="p">([]</span><span class="o">,</span> <span class="nv">ST,</span> <span class="nv">ST</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">createSymbolTable</span><span class="p">([[</span><span class="nv">define,</span> <span class="nv">ident</span><span class="p">(</span><span class="nf">Id</span><span class="p">)</span><span class="o">,</span> <span class="nv">Number</span><span class="p">]</span><span class="nv">|OtherStmts</span><span class="p">]</span><span class="o">,</span> <span class="nv">STSoFar,</span> <span class="nv">ST</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">number</span><span class="p">(</span><span class="nf">Number</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">createSymbolTable</span><span class="p">(</span><span class="nf">OtherStmts,</span> <span class="p">[[</span><span class="nv">Id,Number</span><span class="p">]</span><span class="nv">|STSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">ST</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">createSymbolTable</span><span class="p">([</span><span class="nv">_|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">ST</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">createSymbolTables</span><span class="p">(</span><span class="nf">T,ST</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最后一个谓词是为了在创建符号表的过程中，只关心define语句，忽略掉其他运算语句。</p>

<p>关于符号表，创建它只是故事的一半，通过符号表查询某个变量的值是另一件重要的事。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">search</span><span class="p">(</span><span class="nf">_,</span> <span class="p">[]</span><span class="o">,</span> <span class="nv">_</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">false</span><span class="o">.</span>
</span><span class='line'><span class="nv">search</span><span class="p">(</span><span class="nf">Id,</span> <span class="p">[[</span><span class="nv">Id,Value</span><span class="p">]</span><span class="nv">|_</span><span class="p">]</span><span class="o">,</span> <span class="nv">Value</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">search</span><span class="p">(</span><span class="nf">Id,</span> <span class="p">[</span><span class="nv">_|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Value</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">search</span><span class="p">(</span><span class="nf">Id,</span> <span class="nv">T,</span> <span class="nv">Value</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>当遍历到最后一个符号表的时候，如果仍然找不到某个变量的值，这将被认为是一个程序错误，所以，上面第一个search谓词是以false结束的。另外，如果search在第一个谓词时失败的话，它已经没有回朔的余地了，这样将继而导致整个Prolog运行时失败。这个行为是合理的，任何时候，当遇到一个没有定义的变量时程序都应该停机。</p>

<p>创建完成了符号表，我们现在可以扩展运行时来支持定义变量了。运行时现在应该遍历两次AST，第一次创建符号表ST，第二次解释求值：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">scheme</span><span class="p">(</span><span class="nf">Stmts</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">createSymbolTables</span><span class="p">(</span><span class="nf">Stmts,</span> <span class="nv">ST</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">run</span><span class="p">(</span><span class="nf">Stmts,</span> <span class="nv">ST</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到run谓词已经多了一个ST参数，ST也会进而传递给下面的getValue谓词。在前面的代码中，getValue可以对四则运算和数字求值了，现在我们要扩展它，让它可以对变量求值，当然，这是指从符号表中找出这个变量对应的值：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getValue</span><span class="p">(</span><span class="nf">ST,</span> <span class="nv">ident</span><span class="p">(</span><span class="nf">Id</span><span class="p">)</span><span class="o">,</span> <span class="nv">Value</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">search</span><span class="p">(</span><span class="nf">Id,</span> <span class="nv">ST,</span> <span class="nv">Value</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如刚刚提到的，getValue多了一个参数ST，其他的getValue也是一样，尽管它们并不需要它。</p>

<p>好了，深呼吸一下吧，再整理整理手头的代码。如果你跟上了这篇文章的步伐，会看到一个Scheme子集的运行时环境。如果没跟上也没关系，下面的<a href="https://github.com/isaachan/scheme-runtime">链接</a>提供了源代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (3)：文法分析]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3</id>
    <content type="html"><![CDATA[<p>在<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">上一篇文章</a>中，我们完成了词法分析，从源代码文件中获得了词法单元的序列。接下来，这些词法单元会被送到文法分析器中做进一步处理。我们知道，形式文法是由一组文法生成式组成的。一个生成式可能是这样子的，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='antlr'><span class='line'><span class="nl">IfStat</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">&#39;if&#39;</span><span class="w"> </span><span class="err">&#39;(&#39;</span><span class="w"> </span><span class="err">Expr</span><span class="w"> </span><span class="err">&#39;)&#39;</span><span class="w"> </span><span class="err">StateBlock</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>这是常见的描述if语句的生成式，它表达了这样的含义：如果匹配了‘if’，并且匹配了&#8217;(&#8216;，并且匹配了Expr，并且匹配了&#8217;)&#8217;，并且遇到了StateBlock，那么就匹配了一个完整的IfStat。这里我故意使用了“如果”、“并且”、“那么”，目的是想说明文法生成式和Prolog语句是有着惊人的相似的。每一个生成式实际上就是一个命题。因此，相对于命令式语言，用Prolog进行文法解析是一件比较简单的工作。下面，我们开始用Prolog实现简单Scheme的文法分析部分。</p>

<!-- more -->


<h2>文法分析</h2>

<p>我们先来看一下本文中作为范例的Scheme的文法，它自身非常简单，这也是选择它做范例的原因：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='antlr'><span class='line'><span class="nl">prog</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">statement*</span><span class="w"> </span>
</span><span class='line'><span class="err">statement</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">&#39;(&#39;</span><span class="w"> </span><span class="err">item*</span><span class="w"> </span><span class="err">&#39;)&#39;</span><span class="w"></span>
</span><span class='line'><span class="err">item</span><span class="w"> </span><span class="err">-&gt;</span><span class="w"> </span><span class="err">identifier</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">digit</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">&#39;+&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">&#39;-&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">&#39;*&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">&#39;/&#39;</span><span class="w"> </span><span class="err">|</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="err">statement</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>很简单，是不是？好，下面我们从最高层的谓词开始，由抽象到具体，逐步构造scheme的解析器。第一个谓词是parser，它的输入参数是一串词法单元，输出参数是statement的列表。如果输入的词法单元为空，那么输出的statement也为空；否则，parser会调用其他谓词来收集所有的statement：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">parser</span><span class="p">([]</span><span class="o">,</span> <span class="p">[])</span><span class="o">.</span>
</span><span class='line'><span class="nv">parser</span><span class="p">(</span><span class="nf">Tokens,</span> <span class="nv">Statements</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">matchStatements</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>matchStatements谓词真正完成了收集statment的工作。下面是matchStatements的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">matchStatements</span><span class="p">([]</span><span class="o">,</span> <span class="nv">_,</span> <span class="nv">StatementsSoFar,</span> <span class="nv">Statements</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">reverse</span><span class="p">(</span><span class="nf">StatementsSoFar,</span> <span class="nv">Statements</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">matchStatements</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">Out,</span> <span class="nv">StatementsSoFar,</span> <span class="nv">Statements</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">statement</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">TempOut,</span> <span class="nv">OneStatement</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">matchStatements</span><span class="p">(</span><span class="nf">TempOut,</span> <span class="nv">Out,</span> <span class="p">[</span><span class="nv">OneStatement|StatementsSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Statements</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>它和前面getTokens谓词几乎是一样的。事实上，无论是识别Token，还是识别statement，它们的过程并无本质的区别。</p>

<p>接下来看看statement谓词如何实现。从前面的文法可知，要匹配statement，需要先匹配一个左括号，然后是若干个item，最后是一个右括号。把这段话“翻译”为Prolog代码是很容易的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">statement</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">Out,</span> <span class="nv">Items</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">match</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">lp,</span> <span class="nv">AfterMatchedLp</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">matchItems</span><span class="p">(</span><span class="nf">AfterMatchedLp,</span> <span class="nv">AfterMatchedItems,</span> <span class="nv">Items</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">match</span><span class="p">(</span><span class="nf">AfterMatchedItems,</span> <span class="nv">rp,</span> <span class="nv">Out</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们遇到两个新的谓词，match和matchItems。首先是match，它用于推断一个词法单元序列的第一个元素是否是某个特定的词法单元，而它的输出参数是去掉一个元素后剩余的词法单元。由于match非常简单，此处暂时不给出其代码了。</p>

<p>最后是matchItems谓词。它的任务就是收集statement中的每一项（item），比如对于(+ 1 2)，matchItems就会发现三个项，&#8217;+&#8217;、&#8217;1&#8217;、&#8217;2&#8217;；另外，对于(+ (- 3 2) 1)，matchItems也会发现三个项，&#8217;+&#8217;、&#8217;(- 3 2)&#8217;、&#8217;1&#8217;，不过第二项比较特殊，它又是一个statement，由另外三项组成。最后，何时结束matchItems呢？那就是当matchItems遇到&#8217;(&#8216;的时候。基于上述讨论的三种情况，我们需要分别写出三个matchItems谓词，按照由特殊到一般的原则，我们首先处理matchItems遇到&#8217;(&#8216;和&#8217;)&#8217;的情况，最后是一般的情况。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">matchItems</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">Out,</span> <span class="nv">ItemsSoFar,</span> <span class="nv">Items</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">statement</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">TempOut,</span> <span class="nv">ItemValue</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">matchItems</span><span class="p">(</span><span class="nf">TempOut,</span> <span class="nv">Out,</span> <span class="p">[</span><span class="nv">ItemValue|ItemsSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Items</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">matchItems</span><span class="p">([</span><span class="nv">rp|In</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="nv">rp|In</span><span class="p">]</span><span class="o">,</span> <span class="nv">ItemsSoFar,</span> <span class="nv">Items</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">reverse</span><span class="p">(</span><span class="nf">ItemsSoFar,</span> <span class="nv">Items</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">matchItems</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">Out,</span> <span class="nv">ItemsSoFar,</span> <span class="nv">Items</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">match</span><span class="p">(</span><span class="nf">In,</span> <span class="nv">Item,</span> <span class="nv">TempOut</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">matchItems</span><span class="p">(</span><span class="nf">TempOut,</span> <span class="nv">Out,</span> <span class="p">[</span><span class="nv">Item|ItemsSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Items</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>相信现在你应该能够很容易地看懂这段代码了吧。</p>

<p>最后我们再来看看解析器的输出。前面file和getTokens的谓词都十分明确，前者是文件的字节流，后者是词法单元的序列。而parser的输出通常有两种，一种是基于语法制导，在解析的过程里完成对语言的解释和执行，很多脚本语言和简单的语言都是这样做的；另一种则是生成抽象语法树(AST)或者其他中间形式，以供后续的阶段消费。多数复杂的语言都会在解析阶段输出AST。AST相对于源代码要精简很多，便于语言运行时进行多趟处理，比如优化、类型推演等，是难以在一趟中完成的。在本文的例子中，由于我们要支持define定义的变量，而且变量的定义是可以后于其使用的，因此运行时需要在编译后和运行前增加一个步骤——创建符号表。综上，本文选择了AST作为parser谓词的最终输出。</p>

<p>然而，Prolog并不直接支持tree数据结构，只有支持列表，如何用列表实现tree是二维结构呢？这也不难。计算机的存储结构自身是一维线性的，本质上就是一个列表，因此任何tree结构最终都要转化成列表，比如下面的tree</p>

<p><img src="http://isaachan.github.com/images/scheme-parser-using-prolog/computer.gif" alt="计算机结构图" />
计算机结构图</p>

<p>那么我们可以用下面的列表表示这棵树[computer, [cpu, Intel, 2.83G], [memery, 8G, DDR], [monitor, 15&#8217;, LCD], [keyborad, “USA Standard”]]，这样二维的数据结构就可以由一维的列表表示了。对于Prolog来说，这件事格外容易。假如有下面的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么parser谓词的输出将是：[[define, a, 1], [add, [minus, 3, 2], 1]]。最外层的列表包含两个元素，[define, a, 1]和[add, [minus, 3, 2], 1]，它们分别都是列表，并且第二个元素中又包含了其他的列表。</p>

<p>现在，可以把我们已经有的谓词组合到一起了，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">:-</span> <span class="nv">file</span><span class="p">(</span><span class="err">“</span><span class="nv">example</span><span class="o">.</span><span class="nv">ss</span><span class="err">”</span><span class="o">,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>   <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>   <span class="nv">parser</span><span class="p">(</span><span class="nf">Tokens,</span> <span class="nv">Statements</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>下来是本文的<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-4/">最后一部份</a>，scheme的运行时，启程吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (2)：词法分析]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/"/>
    <updated>2014-10-04T09:49:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2</id>
    <content type="html"><![CDATA[<p>在上一篇“<a href="http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/">读取源文件</a>”的文章中，我们实现了readFile谓词，利用它可以读取源文件的内容，并把字节流保存在一个整数的列表中。接下来我们将消费这些数据，通过它们创建词法单元。因此，本节将讲述如何构造一个词法分析器来完成这件事。</p>

<h2>词法分析</h2>

<p>就像在第一节已经指出的，本文处理的只是Scheme的子集，它的词法规则如下：</p>

<ul>
<li>+, -, *, /, (, ),Whitespace</li>
<li>&#8216;define&#8217;</li>
<li>identifier number</li>
</ul>


<!-- more -->


<p>第一行列出的词法单元只包含一个字符，第二行的‘define’是一个关键字，虽然它不是一个字符组成的，但是仍然是固定长度的。第三行的identifier和number是标识符和数字，它们几乎出现在所有语言中，并且它们的长度不是固定的。</p>

<p>很明显，第一行中的词法单元是最容易识别的，下面这些谓词描述如何识别它们：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">40</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">lp</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="p">(</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">41</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">rp</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="p">)</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">42</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">mult</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">*</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">43</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">plus</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">+</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">45</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">minus</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">-</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">47</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">div</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">/</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">32</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">9</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">10</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">WhiteSpace</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码实现了getToken谓词，这个谓词的第一个参数是进行词法单元匹配以前的字节流，第二个参数是匹配过词法单元后剩余的字符流，第三个参数表示此次getToken匹配到的词法单元。代码中出现的整数，40，41，42&#8230;是字符的ASCII码，后面的注释解释了它代表的字符。上述代码中的[40|Rest]的词法单元是一个列表，它的第一个元素是40，其他元素是Rest。这很类似于scheme中的car和cdr操作。[]则表示一个空的列表。Prolog的这种文法极大的方便了列表的处理。如果你熟悉Erlang，会发现它和Prolog处理列表的文法和语义是一样的（事实上这两种语言也确实深有渊源！）。</p>

<p>接下来，我们看看如何识别define关键字。由于这个词法单元的长度是固定的，因此识别它也并不复杂：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="mi">100</span><span class="o">,</span><span class="mi">101</span><span class="o">,</span><span class="mi">102</span><span class="o">,</span><span class="mi">105</span><span class="o">,</span><span class="mi">110</span><span class="o">,</span><span class="mi">101</span><span class="nv">|Rest</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">define</span><span class="p">)</span><span class="o">.</span> <span class="nv">%%</span> <span class="nv">define</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们用到了列表的另一种文法，[100,101,102,105,110,101|Rest]表示列表的前六个元素一次是 100,101,102,105,110,101。因此这个谓词可以匹配define。</p>

<p>现在我们已经可以匹配除标识符和数字以外的其他词法单元了，那么如何把所有匹配到的词法单元收集到一起呢？嗯，我们需要一个getTokens谓词来收集词法单元，如果输入的字节列表为空，那么收集工作宣告结束；否则，它应该能重复地调用getToken，前一个getToken的输出是后一个getToken的输入。哦，对了，Prolog没有for循环，用递归才能实现重复执行一段代码的工作。OK，getTokens谓词的代码应该是这样子了：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getTokens</span><span class="p">([]</span><span class="o">,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">reverse</span><span class="p">(</span><span class="nf">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">OneToken</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="p">[</span><span class="nv">OneToken|TokensSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>TokensSoFar用来收集计算过程中匹配的词法单元，但是它收集的顺序和词法单元真正的顺序是相反的，因为geTokens总是把后遇到的词法单元放到TokensSoFar的头部，这是受到Prolog列表处理的限制。当输入字节流为空时，把TokensSoFar中的词法单元反向排序，就得到了我们想要的答案。</p>

<p>在进行词法分析的过程中，我们通常要丢弃一些无用的词法单元，比如注释、空白符等等。我们的Scheme子集不支持注释，所以这里我们只要丢弃掉空白符即可。当getTokens遇到一个ws词法单元的时候，不要把它加到TokensSoFar的头部，而是直接忽略掉：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getTokens</span><span class="p">([]</span><span class="o">,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">reverse</span><span class="p">(</span><span class="nf">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">ws</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">getTokens</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">TokensSoFar,</span> <span class="nv">Tokens</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">Input,</span> <span class="nv">Rest,</span> <span class="nv">OneToken</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getTokens</span><span class="p">(</span><span class="nf">Rest,</span> <span class="p">[</span><span class="nv">OneToken|TokensSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个getTokens谓词的位置很重要，它必须位于原来两个谓词之间。Prolog在模式匹配相同签名的谓词的时候，会按照它们声明的先后顺序进行尝试，因此必须把描述特殊情况的谓词排在前面，一般情况的谓词排在后面。</p>

<p>词法分析完成了吗？不不，我们还没有实现匹配标识符和数字的谓词！标识符和数字稍微复杂一些，它们的长度不是固定的，因此在匹配它们的getToken谓词中，还需要多一个参数，用来临时保存计算过程中已匹配的字节。在实现getToken之前，先看一下描述数字的自动机，</p>

<p><img src="http://isaachan.github.com/images/scheme-parser-using-prolog/number-fsm.gif" alt="状态机" /></p>

<p>标识符的自动机和它是类似的。我们可以这样描述该自动机的行为：如果输入的第一个字节是数字，则进入number状态，并记录下这个数字；在number状态下，如果输入的第一个字节是数字，则继续追加该数字； 在number状态下，如果输入的第一个字节是字符，则是非法输入；在number状态下，如果输入的第一个字节是+ - * / ( ) Ws中的任何一个，则结束number状态，并完成一个number词法单元的识别。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">getToken</span><span class="p">([</span><span class="nv">D|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">Nubmer</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getNumberToken</span><span class="p">(</span><span class="nf">T,</span> <span class="nv">Rest,</span> <span class="p">[</span><span class="nv">D</span><span class="p">]</span><span class="o">,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getNumberToken</span><span class="p">([</span><span class="nv">D|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">Rest,</span> <span class="nv">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">getToken</span><span class="p">(</span><span class="nf">T,</span> <span class="nv">Rest,</span> <span class="p">[</span><span class="nv">D|DigitsSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">getNumberToken</span><span class="p">([</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="nv">H|T</span><span class="p">]</span><span class="o">,</span> <span class="nv">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">single</span><span class="p">(</span><span class="nf">H</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">reverse</span><span class="p">(</span><span class="nf">DigitsSoFar,</span> <span class="nv">Number</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">digit</span><span class="p">(</span><span class="nf">D</span><span class="p">)</span> <span class="nv">:-</span> <span class="mi">47</span> <span class="nv">&lt;</span> <span class="nv">D,</span> <span class="nv">D</span> <span class="nv">&lt;</span> <span class="mi">58</span><span class="o">.</span>
</span><span class='line'><span class="nv">single</span><span class="p">(</span><span class="nf">T</span><span class="p">)</span> <span class="nv">:-</span> <span class="nv">T=39</span><span class="c1">; T=9; T=10; T=40; T=41; T=42; T=43; T=45; T=47.</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个getToken谓词描述了从非number状态到number状态的转换。进入Number状态后，开始调用getNumberToken谓词。getNumberToken谓词有两个，分别处理digit和那些只包含一个字符的词法单元。出于简单的考虑，这段程序没有显式地处理遇到字母字符的情况（比如打印一段错误信息），那么，如果在number状态下遇到字母字符时，由于没有相应的谓词可以去匹配，程序同样无法成功运行。最后，在程序的第一行，Rest的值也不是根据它前面的参数确定的了。因为只有读取完所有连续的数字后，才知道Rest的起点在哪里。在第9行，Rest最终被确定下来。这里Rest之所以是[H|T]而不是T，因为当读到一个符合single谓词的字节时，意味着number读取结束了，而刚刚读到的这个字节还要留给下一个谓词去处理，不能在这里吞噬掉。</p>

<p>关于匹配标识符的谓词，和匹配number的谓词几乎一样，在这里就不多赘述了。本文后面会提供所有的源代码。</p>

<p>目前getTokens谓词需要三个参数，FileContent, TokensSoFar和Tokens。其中TokensSoFar的初始值必然是一个空的列表。因此，我们可以再创建一个谓词来“封装”这里参数，从而留给调用者一个更友好的API。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'>   <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">Tokens</span><span class="p">)</span>
</span><span class='line'>       <span class="nv">:-</span> <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="p">[]</span><span class="o">,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，我们有file和getTokens两个谓词了，把它们写在一起已经可以分析指定文件的词法了。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">:-</span> <span class="nv">file</span><span class="p">(</span><span class="err">“</span><span class="nv">example</span><span class="o">.</span><span class="nv">ss</span><span class="err">”</span><span class="o">,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>   <span class="nv">getTokens</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">Tokens</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下了，将是更有挑战的工作——<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-3/">文法分析</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme on Prolog (1)：读取源文件]]></title>
    <link href="http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1/"/>
    <updated>2014-10-02T22:53:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/10/02/build-simple-scheme-parser-using-prolog-1</id>
    <content type="html"><![CDATA[<p>在接下来的一系列文章里，我将详细讲述如何利用Prolog，从零开始构造一个Scheme子集的<a href="https://github.com/isaachan/scheme-runtime">运行时环境</a>。这个运行时环境可以解释执行如下四则运算的Scheme代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，它还可以通过“define”定义变量，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>选择Scheme的原因在于它足够简单而且有趣。另外，通过实现这个简单的运行时环境，我们也可以领略Prolog的独特之处。Prolog作为应用最广泛的逻辑式程序设计语言，在描述文法生成式时具有很多语言无可比拟的优势；另外作为声明式语言，Prolog不必描述运算的细节（甚至语句执行的顺序），因此程序的可读性比命令式语言要好很多。</p>

<!-- more -->


<p>正如前面的代码所示，我们实现的解析器只能执行简单的四则运算，但是它却涉及到读取源文件、词法分析、语法分析和构造符号表等技术，这些是所有高级编译器都具有的功能。因此本文分为四个部分，分别讲述下面四个问题：</p>

<ul>
<li>读取源文件</li>
<li>词法分析</li>
<li>语法分析</li>
<li>运行时环境</li>
</ul>


<h2>读取源文件</h2>

<p>读取源代码文件是后续分析、解释执行的第一步。这个示例程序并没有提供交互式运行的机制，因此从文本文件中读取代码并运行是唯一的启动程序的方式。</p>

<p>谓词推演是Prolog解决问题的手段，无论待解决的问题看上去和谓词推演多么的不相关。不过，谓词推演是足够强大的，足以解决“读取文件内容”的问题。我们设计一个谓词，用来从最高的层次上读取文件的内容：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">file</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个谓词的含义是：当FilePath是一个文件路径，并且FileContent是该文件的内容时，这个谓词为真，否则为假。当然，如果我们只告诉这个谓词FilePath的信息，Prolog运行时会找到FileContent的值，使这个谓词为真。正是由于这一点，file谓词可以为我们读取文件的内容了。</p>

<p>为了实现这个谓词，我们还需要完成一些工作，比如如何获取Prolog运行时内部的文件句柄？如何从文件句柄中依次读取数据？如何知道是否读到了文件的尾部？</p>

<p>调用其他Prolog运行时内置的与文件相关的谓词，它们要能够获取文件句柄，并从句柄中依次读取文件字节。简单地查找Prolog的文档，不难发现下面两个内置的谓词：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">open</span><span class="p">(</span><span class="nf">+FilePath,</span> <span class="nv">+OpenMode,</span> <span class="nv">-Stream,</span> <span class="nv">+Options</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">get0</span><span class="p">(</span><span class="nf">+Stream,</span> <span class="nv">-Char</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>open谓词的第一个参数是文件路径，第二个是打开文件的模式，可以是read/write/append/update之中的一个，第三个是文件句柄，第四个是额外的选项，比如字符集、缓存大小等。get0的第一个参数是文件句柄，它通常是open的输出参数Stream，第二个参数是读出的字符。get0会维护访问文件的指针，当每次调用get0时，指针会自动向后移动，当到达文件尾部的时候，Char等于-1。有了这两个谓词，我们可以进一步实现file谓词，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">file</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">open</span><span class="p">(</span><span class="nf">FilePath,</span> <span class="nv">read,</span> <span class="nv">Stream,</span> <span class="p">[</span><span class="nv">eof_action</span><span class="p">(</span><span class="nf">eof_code</span><span class="p">)])</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Steam,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里增加了一个readFile谓词，它会把Stream中的字节流保存到FileContent中。谓词readFile的实现可以描述如下：如果从Stream中读取的字节是-1（即到文件尾），那么读取完毕；如果从Stream中读取的字节不是-1，那么把该字节追加到已经读取的序列中，然后递归地调用readFile。下面的代码反映了这一描述：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="mi">-1</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">reverse</span><span class="p">(</span><span class="nf">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">ContentSoFar,</span> <span class="nv">FileContent</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Char</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="p">[</span><span class="nv">Char|ContentSoFar</span><span class="p">]</span><span class="o">,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，我们首先为readFile增加了一个参数：ContentSoFar，用来保存在计算过程中收集的不完整的文件内容，当将文件全部读取结束后，再把ContentSoFar的内容反序排列后与FileContent进行合一。我们注意到在第二个readFile中，[Char|ContentSoFar]会导致先读取到字节后放到ContentSoFar序列的后端。这就是说，如果读取的文件内容是123abc，那么ContentSoFar最终的值将是[&#8216;c&#8217;, &#8216;b&#8217;, &#8216;a&#8217;, &#8216;3&#8217;, &#8216;2&#8217;, &#8216;1&#8217;]。因此在第一个readFile的最后，需要把ContentSoFar反序排列后再与FileContent进行合一。</p>

<p>另外，get0的文档提到了，它读取的字节是一个int数值，代表了这个字节的ASCII码。出于测试的目的，我们不想看到读出的内容是一串数字，那么可以用atom_chars谓词将数字串转化为字符串，并使用write谓词将它输出到控制台上：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">display</span><span class="p">(</span><span class="nf">file</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">file,</span> <span class="nv">FileContent</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">atom_char</span><span class="p">(</span><span class="nf">FileContent,</span> <span class="nv">FileContentChar</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">write</span><span class="p">(</span><span class="nf">FileContentChar</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在回过头来看看我们刚刚完成的readFile谓词，它的运行起来效果如何呢？我在尝试读取的文件如下文件：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">11</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>发现程序总是意外出错中止。检查了错误信息后，我发现它读取的内容是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">dfn</span> <span class="mi">1</span>
</span><span class='line'><span class="nv">+1a</span>
</span></code></pre></td></tr></table></div></figure>


<p>程序每读取一个字节会跳过一个字节。经过分析，我找到了错误的原因。当调用readFile谓词的时候，Prolog首先尝试第一个readFile的定义，即调用get0，并期望读到文件尾（-1），这当然是不成立的，于是程序回朔，继续尝试第二个readFile的定义。但是上一次失败已经改变了get0内部维护的文件指针，而且文件指针也不会随着回朔而改变，这就产生了我们前面看到的情况。每经由递归读取一个字节时，都要尝试第一个readFile的定义，而直到真的读取到了文件尾之前，它总是会失败而引起回朔，从而丢失一个字节。为了修正这个问题，需要如下修改我们的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Content</span><span class="p">)</span> <span class="nv">:-</span>
</span><span class='line'>    <span class="nv">get0</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A</span><span class="p">)</span><span class="o">,</span>
</span><span class='line'>    <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A,</span> <span class="nv">Content</span><span class="p">)</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">_,</span> <span class="mi">-1</span><span class="o">,</span> <span class="p">[])</span><span class="o">.</span>
</span><span class='line'><span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">A,</span> <span class="p">[</span><span class="nv">A|Content</span><span class="p">])</span> <span class="nv">:-</span> <span class="nv">readFile</span><span class="p">(</span><span class="nf">Stream,</span> <span class="nv">Content</span><span class="p">)</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，判断读取的字符是否为-1的任务下推给了readFile谓词，确保get0不会参与到回朔过程。另外，由于使用了不同的递归方式，新的实现可以直接读取正确顺序的文件字节流，不需要再次反序排列。</p>

<p>完成了读取源文件的工作，接下来我们就可以进行<a href="http://isaachan.github.com/blog/2014/10/04/build-simple-scheme-parser-using-prolog-2/">词法分析</a>了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTPS背后的加密算法]]></title>
    <link href="http://isaachan.github.com/blog/2014/07/20/cipher-behind-https/"/>
    <updated>2014-07-20T19:03:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/07/20/cipher-behind-https</id>
    <content type="html"><![CDATA[<p>当你在浏览器的地址栏上输入https开头的网址后，浏览器和服务器之间会在接下来的几百毫秒内进行大量的通信。InfoQ的这篇<a href="http://www.infoq.com/articles/HTTPS-Connection-Jeff-Moser">文章</a>对此有非常详细的描述。这些复杂的步骤的第一步，就是浏览器与服务器之间协商一个在后续通信中使用的密钥算法。这个过程简单来说是这样的：</p>

<ol>
<li>浏览器把自身支持的一系列Cipher Suite（密钥算法套件，后文简称Cipher）[C1,C2,C3, &#8230;]发给服务器；</li>
<li>服务器接收到浏览器的所有Cipher后，与自己支持的套件作对比，如果找到双方都支持的Cipher，则告知浏览器；</li>
<li>浏览器与服务器使用匹配的Cipher进行后续通信。<!-- more -->如果服务器没有找到匹配的算法，浏览器（以Firefox 30为例，后续例子中使用的浏览器均为此版本的Firefox）将给出错误信息:</li>
</ol>


<p><img src="http://isaachan.github.com/images/cipher-behind-https/ssl-error-no-cypher-overlap.png" alt="Secure连接失败错误" />
图1</p>

<p>本文将讲述如何探究这一过程。</p>

<h2>1. 浏览器</h2>

<p>浏览器支持哪些Cipher？这取决于浏览器支持的SSL/TLS协议的版本。习惯上，我们通常把HTTPS与SSL协议放到一起；事实上，SSL协议是Netcape公司于上世纪90年代中期提出的协议，自身发展到3.0版本。1999年该协议由ITEL接管，进行了标准化，改名为TLS。可以说，TLS 1.0就是SSL 3.1版本。在Wikipedia上并没有SSL独立的条目，而是会重定向到<a href="http://en.wikipedia.org/wiki/Secure_Sockets_Layer">TLS</a>，可见两种协议关系之紧密。目前TLS最新版本是1.2。互联网上有超过99%的网站支持TLS 1.0，而支持TLS 1.2的网站尚不足40%。打开Firefox浏览器，在地址栏中输入about:config，然后搜索tls.version，会看到下面的选项:</p>

<p><img src="http://isaachan.github.com/images/cipher-behind-https/about-config.png" alt="AboutConfig" />
图2</p>

<p>其中security.tls.version.min和security.tls.version.max两项决定了Firefox支持的SSL/TLS版本，根据<a href="http://kb.mozillazine.org/Security.tls.version.%2A">Firefox文档</a>的介绍，这两项的可选值及其代表的协议是：</p>

<ul>
<li>0 - SSL 3.0</li>
<li>1 - TLS 1.0</li>
<li>2 - TLS 1.1</li>
<li>3 - TLS 1.2</li>
</ul>


<p>因此上图的设置说明当前浏览器支持协议的下限是SSL 3.0，上限是TLS 1.2。现在，如果把security.tls.version.min一项改为3，那么浏览器就只支持TLS 1.2了。前文提到，目前只有不足40%的网站支持TLS 1.2，比如Amazon就不在这40%之列，所以此时访问https://amazon.com，就会收到“Secure Connection Failed”的错误信息，如图2所示。</p>

<p>了解了SSL/TLS协议后，可以使用Wireshark（或类似的可以抓去网络包的工具）通过分析网络包的信息，来查看浏览器发送给服务器的所有Cipher。Wireshark是一款<a href="http://www.cnblogs.com/tankxiao/archive/2012/10/10/2711777.html">使用简单却非常强大</a>的抓包工具。</p>

<p>浏览器会首先发起握手协议，既一个“ClientHello”消息，在消息体中，可以找到Firefox支持的Cipher。在Wireshark中，按照Protocol协议排序，然后从TLS 1.2协议的报文中找到一个Info为“Client Hello”的。选中这个，然后在下面的报文信息窗口中依次找到Secure Sockets Layer -> TLSv1.2 Record Layer -> Handshake Protocal -> Cipher Suites。例子中的第一个Cipher是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256，一共有23个:</p>

<p><img src="http://isaachan.github.com/images/cipher-behind-https/wireshark-screenshot-clienthello.png" alt="clienthello" />
图3</p>

<p>如果继续找一个Info为“ServerHello”的报文，可以在类似的位置找到服务器返回的Cipher，在本例中是TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:</p>

<p> <img src="http://isaachan.github.com/images/cipher-behind-https/wireshark-screenshot-serverhello.png" alt="serverhello" />
图4</p>

<p>关于密钥算法这一长串名字的含义，后面说明。接下来，浏览器就要等待服务器响应它的请求。我们来看一看服务器端都做了些什么。</p>

<h2>2. 服务器</h2>

<p>让我们以Windows为例。若要查看操作系统支持哪些密钥算法，可以运行gpedit.msc，依次进入”Computer Configuration” -> ”Administrative Templates” -> “Network” -> “SSL Configuration Settings”，这时可以在窗口右边看到”SSL Cipher Suite Order”项:</p>

<p><img src="http://isaachan.github.com/images/cipher-behind-https/gpedit.png" alt="gpedit" />
图5</p>

<p>点击该项后进入”SSL Cipher Suite Order”。这里可以看到操作系统支持的Cipher的集合，以及对不同Cipher的排序</p>

<p><img src="http://isaachan.github.com/images/cipher-behind-https/ssl-suite-order.png" alt="cipher-suite-order" />
图6</p>

<p>如果需要调整这里排序，或者去掉一些弱的Cipher，可以点击左上角的“Enabled”，然后在“Options”中重写编辑Cipher的列表。如果喜欢命令行，可以通过下面的Powershell命令修改密钥算法套件：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="nb">Set-ItemProperty</span> <span class="n">-path</span> <span class="n">HKLM</span><span class="err">:</span><span class="p">\</span><span class="n">SOFTWARE</span><span class="p">\</span><span class="n">Policies</span><span class="p">\</span><span class="n">Microsoft</span><span class="p">\</span><span class="n">Cryptography</span><span class="p">\</span><span class="n">Configuration</span><span class="p">\</span><span class="n">SSL</span><span class="p">\</span><span class="n">0001002</span> <span class="n">-name</span> <span class="n">Functions</span> <span class="n">-value</span> <span class="s2">&quot;XXX,XXX,XXX&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么Cipher的这一长串名字是什么含义呢？其实，每种<a href="http://en.wikipedia.org/wiki/Cipher_suite">Cipher</a>的名字里包含了四部分信息，分别是</p>

<ul>
<li><strong>密钥交换算法</strong>，用于决定客户端与服务器之间在握手的过程中如何认证，用到的算法包括RSA，Diffie-Hellman，ECDH，PSK等</li>
<li><strong>加密算法</strong>，用于加密消息流，该名称后通常会带有两个数字，分别表示密钥的长度和初始向量的长度，比如DES 56/56, RC2 56/128, RC4 128/128, AES 128/128, AES 256/256</li>
<li><strong>报文认证信息码（MAC）算法</strong>，用于创建报文摘要，确保消息的完整性（没有被篡改），算法包括MD5，SHA等。</li>
<li><strong>PRF（伪随机数函数）</strong>，用于生成“master secret”。</li>
</ul>


<p>完全搞懂上面的内容似乎还需要一本书的介绍（我已经力不从心了）。不过大致了解一下，有助于理解Cipher的名字，比如前面服务器发回给客户端的Cipher，</p>

<p> <strong>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</strong></p>

<p>从其名字可知，它是</p>

<ul>
<li>基于TLS协议的；</li>
<li>使用ECDHE、RSA作为密钥交换算法；</li>
<li>加密算法是AES（密钥和初始向量的长度都是256）；</li>
<li>MAC算法（这里就是哈希算法）是SHA。</li>
</ul>


<p>熟悉了Cipher名字背后的含义后，让我们看看像IIS这样的Web服务器如何选择一个密钥算法呢？假如浏览器发来的密钥算法套件为[C1, C2, C3]，而Windows Server支持的套件为[C4, C2, C1, C3]时，C1和C2都是同时被双方支持的算法，IIS是优先返回C1，还是C2呢？<strong>答案是C2</strong>。IIS会遍历服务器的密钥算法套件，取出第一个C4，发现浏览器并不支持；接下来取第二个C2，这个被浏览器支持！于是，IIS选择了C2算法，并将它包含在一个“ServerHello”握手协议中，发回给客户端。这就有了图5中的结果。</p>

<h2>3. 选择</h2>

<p>作为浏览器的使用者，你可以让浏览器只能访问支持TLS 1.2协议的站点，以获得更好的安全性，以及更差的体验。作为服务器的维护者，似乎将最强壮的Cipher排在前面是正确的选择。就在前不久，我们开发的一个Web报税系统在一次由第三方进行的安全检查中，被报出的问题之一就是服务器默认的Cipher太弱（RC4-based），于是我们使用了AES-based的Cipher，但是密钥长度只是选择了128，而不是256，背后的担忧主要来自于性能——加密与解密是CPU密集型操作，我们担心到报税忙季时，过强的Cipher会带来性能问题。</p>

<p>其实像Amazon和<a href="http://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe">Google</a>这些互联网公司都在使用RC4-based的加密算法。这又是一次理论与实践的交锋。至于这次对于的线上系统所做的调整会不会对性能产生影响，几个月后就能见分晓了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[展望2014，马上持续交付]]></title>
    <link href="http://isaachan.github.com/blog/2014/01/28/cd-2013-2014/"/>
    <updated>2014-01-28T16:54:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2014/01/28/cd-2013-2014</id>
    <content type="html"><![CDATA[<p>写这篇博客的时候，农历马年的步伐已经进入倒计时了。很多人都许了愿，“马上有钱”，“马上有对象”。那么，作为处在IT交付核心的我们，还应该再加一个愿望：马上持续交付。</p>

<p>在快速变化的IT行业里，四年是个相当长的时期，很多技术都在这段时间里走完了它的生命周期。从“持续交付”第一次走入行业的视野，到今天大概也就4年的样子，然而它不但没有褪色，反而逐渐受到越来越多的关注了。我们看到，不但越来越多的<a href="https://www.facebook.com/video/video.php?v=10100259101684977&amp;oid=9445547199&amp;comments">互联网</a>企业开始实施了持续交付，很多传统行业，比如金融、保险、电信等等，也都踏入了持续交付之路。我们都知道，持续交付涉及到软件交付的整个生命周期，那么，我们不妨来看一看，哪些因素让持续交付在今后几年里将会得到越来越多的关注。</p>

<h2>市场竞争带来业务驱动力，精益创业引爆持续变革</h2>

<p>如果找一个发展持续交付的“root cause”，市场这只看不见的手绝对当知无愧。两年前开始流行的“精益创业”告诉我们，快速地提供满足最终用户需求的产品，是企业生存之道。对于初创公司，能够比竞争对手提早进入市场，将会获得更大的优势，取得更好的发展前景。传统行业也没有什么可幸运的。它们也面对同样的竞争压力，还要承受自身改变的阻力。我们正在帮助一家跨国金融企业实施持续交付，将它们新产品的发布周期从六个月降低到两周。我们也有来自其他领域的客户，比如保险、电信，为了赢得市场上的竞争，获得更大的生存空间，都在不同程度上迈向了持续交付。</p>

<!-- more -->


<h2>自动化测试深入到不同层次</h2>

<p>一行代码有多大的威力？在内存中创建一个新对象；创建一个Stub的数据库、Web服务器；还是创建一台新的虚拟机。我们可以在不大幅度提高代码复杂度的前提下，完成不同层次的自动化测试。如今，我们可以很容易地构造出干净的领域对象或者假的数据库、第三方服务，因此能够以很低的成本频繁、自动地运行单元测试和集成测试等低层的测试。而随着DevOps、虚拟化技术的成熟，我们也可以很容易地重复创建基础设施，比如下面是我从手头的代码库中复制出的一行代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">vmRef</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">xenapi</span><span class="o">.</span><span class="n">VM</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">templateVM</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>它可以创建一台新的虚拟机。这就让自动化测试能够深入到基础设施的级别，可以更早地发现与之相关的问题。而且，也可以让一些高度依赖基础设施的测试，比如安全测试、性能测试等，可以以更低的成本，更频繁地运行。</p>

<h2>持续集成实践的持续发展</h2>

<p>相比于“持续交付”，“持续集成”的概念就更悠久了，它最早出现在Kent Beck的“极限编程”一书中，日后Martion Fowler也有很好的总结。虽然持续集成最初也提到了将产品部署到生产环境，但是实践中它更多地关注在软件“开发”的部分。良好的持续集成实践帮助我们快速地完成软件开发到QA的测试，确保它正确地反映了BA所描述的需求。不过在这个过程中缺失了让产品接受最终用户检验的环节。</p>

<p>随着越来越多的组织、企业实施了完善的持续集成实践，下一步改进的步伐自然地走到了软件交付的最后一公里——发布、部署到生产环境，这正是持续交付所关注的领域。持续集成的理论与实践的持续发展，很自然地就进入到了持续交付。</p>

<h2>DevOps运动风起云涌</h2>

<p>不记得从什么时候起，服务器监控、SLA、零停机部署、MTBF、MTTR这些名词进入到了我们每天的编程活动中，成为影响我们编写代码的重要因素；在我们的交付物中，测试脚本、部署脚本占据了越来越大的比重；我们从项目开始的第一天开始就关心生产环境的配置，希望能够尽早在一个类生产环境下进行工作。哦！我们一支脚迈入运维的世界了。想到频繁交付，了解企业的运维是必须的。DevOps运动伴随着交付团队与运维团队的更紧密的协作、协调、发布流程全自动化，也已经走向了成熟。</p>

<h2>虚拟化技术与云计算走下神坛</h2>

<p>2013年，虚拟化和云的出镜率一下子提高了。各路厂商仿佛一夜间消除了隔阂，共同向着虚拟化和云进军了。这里我们可以看到Rackspace、Google、RedHat、VMWare、IBM、HP、Intel、Microsoft…似乎能把这些名字放到一起的时候并不多。各种开源的虚拟化方案、云平台也逐渐从玩具走向业界，开始承担生产级的任务，无论是性能还是实施的难度，都得到了极大的改善——这不再是一朵高高在上的云了，它即将变成雨水浇灌众生。虚拟化与云计算的背后，是对于基础设施运维的标准化、快速响应的诉求。回看持续交付，我们发现DevOps与云，从技术的层面帮助我们解决了“最后一公里”的问题。</p>

<h2>再不持续交付我们就老了</h2>

<p>说了这么多，其实一句话就可以概括，2014年，再不持续交付我们就老了。行动吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本化的幻灯片 - 实用技术]]></title>
    <link href="http://isaachan.github.com/blog/2013/08/18/slide-textuality-tips/"/>
    <updated>2013-08-18T21:56:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2013/08/18/slide-textuality-tips</id>
    <content type="html"><![CDATA[<p>不久前在博客上发了一篇使用Slideshow创建幻灯片的<a href="http://isaachan.github.io/blog/2013/08/17/slide-textuality/">文章</a>，不过这篇博文却是在两年多前写的。这两年多里，我在公司内部的演讲幻灯片几乎都是用Slideshow做的，外部演讲也用过几次了，比如<a href="http://www.lisp.org.cn/wiki/lisp/event/2013-meetup">Lisp社区的</a>。在这个过程中，我对Slideshow的强大功能与高效率越来越有信心了。这篇文章分享一些我总结的经验。</p>

<h2>1. 关于使用</h2>

<p>Slideshow本身要求使用者编写scheme代码来创建幻灯片，不过这部分不设计代码，而是一些方便使用的技巧。</p>

<h4>显示下一页预览</h4>

<p>在幻灯片演示的过程中，按住Alt-c（或者Cmd-c）可以开启、关闭下一页幻灯片的预览。图1显示了启动预览时的效果。
<img src="http://isaachan.github.com/images/slide-textuality-tips/slideshow-preview.png" alt="下一页预览" />
图1</p>

<h4>显示注释</h4>

<p>在幻灯片演示的过程中，按住Alt-d（或者Cmd-d）可以显示、隐藏注释内容。至于在幻灯片里添加注释的内容，需要调用comment函数，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;Hello World!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">comment</span> <span class="s">&quot;this is a comment&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<h4>移动窗口位置</h4>

<p>在幻灯片演示的过程中，按住Shift和一个方向键，可以向方向键的方向移动窗口，每次移动一个像素。当演讲时投影仪设备或角度受限时，这个方法能够临时救急。</p>

<h4>导出为PDF格式</h4>

<p>随着越来越多的办公软件与格式的流行，人们共享像幻灯片这类文件时兼容性问题越来越多，好在在很多时候，PDF是个几乎所有人都能接受的格式，于是，几乎所有办公软件都有导出PDF格式的功能。Slideshow也不例外。命令行参数&#8221;-p&#8221;可以告诉Slideshow不要演示幻灯片，而是打印它。打印前只要选择“Save as Pdf”，就可以到处文件，而不必真的执行打印了。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="nv">&gt;</span> <span class="nv">slideshow</span> <span class="nv">-p</span> <span class="nv">helloworld</span><span class="o">.</span><span class="nv">rkt</span>
</span></code></pre></td></tr></table></div></figure>


<h2>2. 关于编码</h2>

<p>前面介绍了一些Slideshow的使用技巧，但是这些确实无法和PowerPoint或者Keynote这类成熟的幻灯片工具比较。而Slideshow真正的优势在于可以通过编写scheme代码来创建幻灯片，因此幻灯片就可以具有代码的那种简洁、抽象、确定、优雅的特性了。这里我列举四个例子，</p>

<h4>介绍题目的幻灯片</h4>

<p>你的幻灯片第一页怎么做？演讲题目、演讲者姓名、公司、邮箱、微博、主页等等。然后排版，标题居中、名字靠右，还是&#8230;其实对于你自己来说，每次的不同只有演讲题目而已，其他的像公司、邮箱、样式等等都可以是一样的，这样能够打造你自己一致的风格。而提取相同的部分，隔离不同的部分——幻灯片已经全部变成代码了——当然可以做到：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">title</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="nv">content</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">slide</span> <span class="p">(</span><span class="nf">vr-append</span> <span class="p">(</span><span class="nb">* </span><span class="nv">gap-size</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">vc-append</span>
</span><span class='line'>               <span class="p">(</span><span class="nb">* </span><span class="nv">gap-size</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nf">adapt</span> <span class="nv">content</span><span class="p">)</span>
</span><span class='line'>             <span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">vr-append</span> <span class="p">(</span><span class="nb">* </span><span class="nv">gap-size</span> <span class="mf">0.5</span><span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;Han Kai&quot;</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;bold</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">))</span> <span class="mi">32</span><span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;http://isaachan.github.com&quot;</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">hc-append</span>
</span><span class='line'>                  <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;Thought&quot;</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;bold</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">))</span> <span class="mi">24</span><span class="p">)</span>
</span><span class='line'>                  <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;Works&quot;</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;@isaachan&quot;</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;bold</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">))</span> <span class="mi">32</span><span class="p">)</span>
</span><span class='line'>             <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码定义了title函数，它接受一个字符串类型的参数，即演讲题目内容，然后将题目以64号字居中显示，右下角以此是演讲名姓名、Blog主页、公司名和微博。那么，当用不同参数调用title函数时，可以看到风格一致、只有题目不同的幻灯片了：（图2）</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">title</span> <span class="s">&quot;Logic programming and Prolog&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://isaachan.github.com/images/slide-textuality-tips/logic_programming_and_prolog.png" alt="title_1" />
图2</p>

<p>当然，如果title部分需要做一些定制，也没有问题：（图3）</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">title</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">text</span> <span class="s">&quot;How to&quot;</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">text</span> <span class="s">&quot; write your own language in 10 mins&quot;</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">)</span> <span class="mi">50</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://isaachan.github.com/images/slide-textuality-tips/how_to_write_your_own_language_in_10_mins.png" alt="title_2" />
图3</p>

<h4>一页一句话</h4>

<p>我们都知道一个演讲的基本原则，就是人是主题，幻灯片是辅助物，因此，应该尽量保持幻灯片简洁，不要密密麻麻地堆彻大量文字。这个原则的一个极限状态就是幻灯片上只有一句话，表明一个主题。我们希望让所有这些幻灯片里的文字都保持同样的样式。这只需一个非常简单的函数就足够了，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">topic</span> <span class="nv">content</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">slide</span> <span class="p">(</span><span class="nf">text</span> <span class="nv">content</span> <span class="p">(</span><span class="nf">current-main-font</span><span class="p">)</span> <span class="mi">70</span><span class="p">))</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数只接受一个字符串类型的参数，为显示在幻灯片上的文字内容。另外它将字号设置为70，使用的是系统默认的字体。</p>

<h4>修改Master版面</h4>

<p>PowerPoint和Keynote都有模版功能，可以对所有的幻灯片做统一的设置。Slideshow也有类似的机制。Slideshow在渲染每一张幻灯片之前，都会调用一个名为current-slide-assembler的函数，Slideshow运行时调用这个函数时，会传入三个参数，slide的title、title与内容的分隔符v-sep、slide的内容。下面的例子完成如下的设置，</p>

<ol>
<li>黑底白字</li>
<li>Title内容靠左，不是默认的居中</li>
</ol>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">set-margin!</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">black-bg</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">filled-rectangle</span> <span class="nv">client-w</span> <span class="nv">client-h</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">current-slide-assembler</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">s</span> <span class="nv">v-sep</span> <span class="nv">c</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">ct-superimpose</span>
</span><span class='line'>      <span class="nv">black-bg</span>
</span><span class='line'>      <span class="p">(</span><span class="k">if </span><span class="nv">s</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">vl-append</span> <span class="nv">v-sep</span> <span class="p">(</span><span class="nf">para</span> <span class="p">(</span><span class="nf">titlet</span> <span class="nv">s</span><span class="p">))</span> <span class="p">(</span><span class="nf">colorize</span> <span class="nv">c</span> <span class="s">&quot;white&quot;</span><span class="p">))</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">colorize</span> <span class="nv">c</span> <span class="s">&quot;white&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">current-title-color</span> <span class="s">&quot;white&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>current-slide-assembler函数接受一个lambda类型的参数，这个lambda接受三个参数。black-bg函数会画一个和用户可见区域一样大小的黑色矩形——这就是“黑底”了。接下来将判断当前幻灯片是否有title，如果有，则将title和内容垂直左对齐；如果没有，则直接显示内容。注意，无论是否有Title，都会将文字的颜色改为白色。最后调用(current-title-color &#8220;white&#8221;)，目的是把Title文字的颜色也改为白色。这就是“白字”了。下面的图4和图5是同样的幻灯片，在改变Master前后的效果，</p>

<p><img src="http://isaachan.github.com/images/slide-textuality-tips/change-master-1.png" alt="改变Master之前" />
图4　</p>

<p><img src="http://isaachan.github.com/images/slide-textuality-tips/change-master-2.png" alt="改变Master之后" />
图5</p>

<h4>布局</h4>

<p>有很多时候，我需要对幻灯片进行布局，比如图6示范了一些可能的形式:</p>

<p><img src="http://isaachan.github.com/images/slide-textuality-tips/left-right.png" alt="布局效果" />
图6</p>

<p>在Slideshow中实现第一种左右平分的布局非常简单，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">left-right-panel</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">ht-append</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">cc-superimpose</span> <span class="p">(</span><span class="nf">blank</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">client-w</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">client-h</span><span class="p">)</span> <span class="nv">left</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">cc-superimpose</span> <span class="p">(</span><span class="nf">blank</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">client-w</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">client-h</span><span class="p">)</span> <span class="nv">right</span><span class="p">)</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>left-right-panel函数接受两个参数，分别是左边和右边的内容。因此，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">left-right-panel</span> <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;World&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>就能实现图6-a的效果了。其中cc-superimpose表示“Hello”和“World”两段文本在各自的区域里面都出于水平居中、垂直居中的位置（cc）。不过，这个函数限制了内容只能在各自的区域内居中，因此无法实现像图6-b那种效果，只是可以修改left-right-panel，使它能够支持不同的居中模式，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="nv">left-right-panel</span>
</span><span class='line'>  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">left</span> <span class="nv">right</span> <span class="p">[</span><span class="nv">left-superimpose</span> <span class="nv">cc-superimpose</span><span class="p">]</span> <span class="p">[</span><span class="nv">right-superimpose</span> <span class="nv">cc-superimpose</span><span class="p">])</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">ht-append</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">left-superimpose</span> <span class="p">(</span><span class="nf">blank</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">client-w</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">client-h</span><span class="p">)</span> <span class="nv">left</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">right-superimpose</span> <span class="p">(</span><span class="nf">blank</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">client-w</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">client-h</span><span class="p">)</span> <span class="nv">right</span><span class="p">)</span>
</span><span class='line'>      <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>更新后的left-right-panel增加了两个参数left-superimpose和right-superimpose，并且默认值为cc-superimpose和cc-superimpose。如果要实现图6-b的效果，可以调用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="nf">left-right-panel</span> <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">t</span> <span class="s">&quot;World&quot;</span><span class="p">)</span> <span class="nv">lt-superimpose</span> <span class="nv">rt-superimpose</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>就可以了。另外，图6的其他几种布局的实现方式和left-right-panel非常类似。</p>

<h2>3.总结</h2>

<p>上面四个例子只是很少的一部分。Slideshow的魅力在于让你可以把关于制作幻灯片的经验、模式，通过代码固化下来，并且降低重用和分享的难度。同时，Slideshow可以帮你把内容和样式进行干净的分离，随着使用经验的增加，你会积累更多的样式函数，那时就可以把精力放在幻灯片的内容上，从而提高生产率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文本化的幻灯片 - Slideshow]]></title>
    <link href="http://isaachan.github.com/blog/2013/08/17/slide-textuality/"/>
    <updated>2013-08-17T22:12:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2013/08/17/slide-textuality</id>
    <content type="html"><![CDATA[<p>作为一名体面的程序员，作为一名被Unix文化侵染的程序员，作为一名希望世界是由简单的纯文本构成的程序员，生活中充满太多无奈。二进制的格式无处不在，后缀名将文件分出了三六九等。这其中，有两种文件我最无奈，图像和幻灯片，它们总和我的工作生活密切相关。</p>

<p>不过，现在光来了！HuKai在一篇<a href="http://www.iamhukai.com/?p=149">blog</a>里介绍了一个很酷的工具——Dot，它提供了一种可以基于文本描述图形的简洁的DSL。利用这个DSL，可以绘制出相当复杂的图案。激动之余，我开始寻找文本化幻灯片的方法。于是，我发现了DrRacket（它的前身就是大名鼎鼎的DrScheme）。DrRacket是MIT开发的Scheme的运行时，其中包含一个制作幻灯片的组件，名曰Slideshow。</p>

<p>很明显，Slideshow要求使用者用scheme来编写幻灯片，这就满足了像我这样的语言控的怪癖。我也因此放弃了一些其他类似的工具，比如SliTex。在Slideshow中，最核心的概念是pict和slide。slide自然表示一张幻灯片，它是由一个或多个pict按照不同的顺序排列组成的。slideshow的源代码以rkt为后缀名。下面是Slideshow的Hello World（hello.rkt）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="o">#</span><span class="nv">lang</span> <span class="nv">slideshow</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">slide</span> <span class="p">(</span><span class="nf">t</span> <span class="err">“</span><span class="nv">Hello</span> <span class="nv">World</span><span class="err">”</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>第一行代码注册了语言的类型，即slideshow，第二行代码包含一个slide函数的调用，它会产生一张幻灯片，幻灯片的内容是(t “Hello World”)函数的结果——包含字符串“Hello World”的pict。t是Slideshow中众多返回pict的函数之一。在默认情况下，slide函数会把pict置于幻灯片的中间，不过它有一个可选的选项layout来控制pict的位置，让我们在刚才的基础上再增加一张幻灯片：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="err">…</span>
</span><span class='line'><span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>   <span class="o">#</span><span class="nv">:layout</span> <span class="ss">&#39;top</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">t</span> <span class="err">“</span><span class="nv">Hello</span> <span class="nv">World</span><span class="err">”</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>layout的值包括&#8217;center，&#8217;top，&#8217;tall和&#8217;auto，&#8217;auto是默认值。slide还有其他选项，title、name、inset和timeout等，可以为slide提供更多可配置的功能。</p>

<p>如果你对t函数使用的字体和大小不满意的话，可以使用text函数来自定义它们。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="err">…</span>
</span><span class='line'><span class="p">(</span><span class="nf">slide</span>
</span><span class='line'>   <span class="o">#</span><span class="nv">:title</span> <span class="err">“</span><span class="nv">Code</span> <span class="nv">Snap</span><span class="err">”</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">text</span> <span class="err">“</span><span class="nv">String</span> <span class="nv">name</span> <span class="nv">=</span> <span class="nv">getNameFromDB</span><span class="p">()</span><span class="c1">;” &#39;(bold . morden), (+ (current-font-size 10))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>我为这张幻灯片增加了title “Code Snap”，它会出现在幻灯片的顶端。然后使用text函数生成一段Java代码片段，为了让它看上去更像“代码”，使用等宽字体morden并加粗，大小也比默认字号大了10。这时在命令行里键入下面的命令</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&gt; slideshow hello.rkt
</span></code></pre></td></tr></table></div></figure>


<p>就能看到前面制作的三张幻灯片依次播放了。如果你现在对Slideshow产生了一点兴趣，那么别犹豫了，在命令行里输入</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&gt; slideshow
</span></code></pre></td></tr></table></div></figure>


<p>就立刻能够看到一个介绍Slideshow入门教程幻灯片，它非常给力，而且它就是用Slideshow制作的，你可以在drrakect的安装目录下找到它的源代码。</p>

<p>希望你能花点儿时间学习一下Slideshow，然后从此爱上幻灯片，爱上Scheme！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chocolatey, 我爱你]]></title>
    <link href="http://isaachan.github.com/blog/2013/02/07/chocolatey-i-love-you/"/>
    <updated>2013-02-07T14:28:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2013/02/07/chocolatey-i-love-you</id>
    <content type="html"><![CDATA[<p>巧克力在很多文化里都代表了美好的事物。如果你是Windows的使用者，可能Windows复杂、丑陋的包管理正在把你折腾的很惨。*NIX平台上的各种优雅的包管理工具这时让人非常眼馋。直到有一天Chocolatey出现了，让我看到了Windows平台上的包管理朝着正确的方向前进了。看来，和巧克力沾边的东西都能让人产生幸福的感觉。</p>

<h2>1. 安装</h2>

<p>Chocolatey的安装过程简单至极，在<a href="http://chocolatey.org/">Chocolatey.org</a>上最醒目的地方有一行命令，把它复制到命令行中运行，只要一分钟左右，安装就完成了。在命令下键入</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">chocolatey</span> <span class="n">help</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以验证安装是否成功。</p>

<!-- more -->


<h2>2. 初体验</h2>

<p>默认情况下，Chocolatey会把自己安装到C:\Chocolatey目录下。该目录下还有三个子目录，它们的作用分别是</p>

<ul>
<li>bin - Chocolatey自身的命令，以及通过Chocolatey安装的某些软件会在bin下增加一个*.bat的快捷方法。</li>
<li>chocolateyInstall - Chocolatey运行时的程序以及各种log。</li>
<li>lib - 安装过程中下载的包。</li>
</ul>


<p>是时候尝试一下Chocolatey的威力了，在命令行上键入</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">chocolatey</span> <span class="n">install</span> <span class="n">7zip</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时会出现下载的进度信息。耐心等一会儿，Chocolatey会告诉你安装完成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>“Finished installing '7zip' and dependencies - if errors not shown in console, none detected. Check log for errors if unsure”</span></code></pre></td></tr></table></div></figure>


<p>这之后检查你的Program Files(或者Program Files (x86))下应该包含7-Zip目录了。</p>

<h2>3. 安装自己的包</h2>

<p>在我写这篇博客的时候，我的机器上并没有中文输入法。在Chocolatey上寻找未果后（<a href="http://chocolatey.org/packages?q=google+pinyin">http://chocolatey.org/packages?q=google+pinyin</a>）（在你读到这篇Blog的时候，我已经上传了Google Pinyin的安装包），我只能自己为Google Pinyin创建一个Chocolatey的安装包。研究过C:\Chocolatey\lib\下面的7Zip的包文件后，我们可以获知创建Chocolatey包的方法。</p>

<p>Chocoletay包一个满足特定目录结构的NuGet包。<a href="http://nuget.org/">NuGet</a>是另一个Windows上令人心动的工具，它是一种特定的包格式，类似于.deb .rpm，同时它也具有版本化的包管理功能。与Chocolatey的不同在于，NuGet关注在开发人员使用的包，而Chocoletay更关注最终用户可用的软件包。既然Chocolatey包就是NuGet包，可以用命令</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">NuGet</span><span class="p">.</span><span class="n">exe</span> <span class="n">pack</span> <span class="p">****.</span><span class="n">nuspec</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建。如果你没有安装NuGet没有关系，Chocolatey包含了一个NuGet的二进制执行文件，可以使用命令</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">cpack</span><span class="p">.</span><span class="n">bat</span> <span class="n">pack</span> <span class="p">****.</span><span class="n">nuspec</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建。cpack.bat可在C:\Chocolatey\bin目录下找到。</p>

<p>不过Chocolatey的包还需要一些特殊的内容，才能被Chocolatey识别并安装。查看7Zip的安装文件后，可以看到我们需要在包的顶级目录下创建一个tools目录，并在下面包含一个chocolateyInstall.ps1文件，该文件是安装包的（PowerShell）代码。 综上所述，我们需要很少的步骤，就能创建Google Pinyin的包：</p>

<p>&#8212; C:/GooglePinyinPackage/google-pinyin.nuspec &#8212;</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;package&gt;</span>
</span><span class='line'>    <span class="nt">&lt;metadata&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>google-pinyin<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;version&gt;</span>1.0<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;title&gt;</span>Google Pinyin<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>        <span class="nt">&lt;authors&gt;</span>Han Kai<span class="nt">&lt;/authors&gt;</span>
</span><span class='line'>        <span class="nt">&lt;owners&gt;</span>Han Kai<span class="nt">&lt;/owners&gt;</span>
</span><span class='line'>        <span class="nt">&lt;requireLicenseAcceptance&gt;</span>false<span class="nt">&lt;/requireLicenseAcceptance&gt;</span>
</span><span class='line'>        <span class="nt">&lt;description&gt;</span>Google pinyin installation for Chinese requirement.<span class="nt">&lt;/description&gt;</span>
</span><span class='line'>        <span class="nt">&lt;copyright&gt;</span>Copyright 2012<span class="nt">&lt;/copyright&gt;</span>
</span><span class='line'>        <span class="nt">&lt;tags&gt;</span>google pinyin<span class="nt">&lt;/tags&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/metadata&gt;</span>
</span><span class='line'>    <span class="nt">&lt;files&gt;</span>
</span><span class='line'>        <span class="nt">&lt;file</span> <span class="na">src=</span><span class="s">&quot;chocolateyInstall.ps1&quot;</span> <span class="na">target=</span><span class="s">&quot;tools/chocolateyInstall.ps1&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/files&gt;</span>
</span><span class='line'><span class="nt">&lt;/package&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>以及
&#8212; C:/GooglePinyinPackage/chocolateyInstall.ps1 &#8212;</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="k">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Install-ChocolateyPackage</span> <span class="s1">&#39;google-pinyin&#39;</span> <span class="s1">&#39;exe&#39;</span> <span class="s1">&#39;/s&#39;</span> <span class="s1">&#39;http://dl.google.com/pinyin/v2/GooglePinyinInstaller.exe&#39;</span>
</span><span class='line'><span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">Write-ChocolateyFailure</span> <span class="s1">&#39;Google Pinyin&#39;</span> <span class="s2">&quot;</span><span class="si">$(</span><span class="err">$</span><span class="si">_.Exception.Message)</span><span class="s2">&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此处使用了Chocolatey提供的Install-ChocolateyPackage函数，它需要四个参数，id（google-pinyin，这个要和google-pinyin.nuspec中的一致），安装文件类型，安装参数（/s是silent installation）和安装文件的下载路径。</p>

<p>这时在C:\google-pinyin目录下运行下面的命令，可以生成google-pinyin.nupack包：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">cpack</span> <span class="n">google-pinyin</span><span class="p">.</span><span class="n">nuspec</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行下面的命令可以安装这个包，</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='powershell'><span class='line'><span class="n">cinst</span> <span class="n">googe-pinyin</span> <span class="n">-source</span> <span class="n">C</span><span class="err">:</span><span class="p">\</span><span class="n">GooglePinyinPackage</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，cinst是chocolatey install的快捷方式。<strong>-source C:\GooglePinyinPackage</strong>非常重要，它将本地C:\GooglePinyinPackage目录设置为cinst的安装软件包源。如果没有这个参数，cinst会在默认的两个源中查找，而后抱怨找不到google-pinyin。cinst的两个默认源是<a href="http://chocolatey.org/api/v2/">这里</a>和<a href="http://chocolatey.org/api/v2/">这里</a>。</p>

<p>现在，安装应该结束了，可以看一看你的输入法列表中是否包含了Google拼音输入法。</p>

<h2>4. 分享你的安装包</h2>

<p>到目前为止，我们安装了两个包，7Zip和Google拼音输入法，一个来自于Chocolatey.org，一个是我自己创建的。Chocolatey.org实际上是个社区，鼓励大家分享不同人创建的安装包。这正是我钟爱Chocolatey的原因！那么，接下来我要把刚刚创建的安装包发布到Chocolatey社区中。</p>

<p>发布安装包需要注册Chocolatey账户。注册完成后，可以在<a href="http://chocolatey.org/packages/upload">这里</a>上传安装包。</p>

<p><img src="http://isaachan.github.com/images/upload-chocolatey-package.png" alt="上传Chocolatey安装包" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于理想]]></title>
    <link href="http://isaachan.github.com/blog/2013/01/31/about-ideal/"/>
    <updated>2013-01-31T22:22:00+08:00</updated>
    <id>http://isaachan.github.com/blog/2013/01/31/about-ideal</id>
    <content type="html"><![CDATA[<p>理想这个东西，刚刚带上总会让人受伤。</p>

<p>但是时间长了以后，它却像鸦片一样，成为你生命里离不开的东西。你每天就为了它而奔波。</p>

<p>你懂的。</p>
]]></content>
  </entry>
  
</feed>
